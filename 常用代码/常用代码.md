# 常用代码

<!-- TOC -->

- [1. 单例模式](#1-单例模式)
- [2. 排序](#2-排序)
  - [2.1. 快速排序`partition`过程](#21-快速排序partition过程)
    - [2.1.1. 方法一](#211-方法一)
    - [2.1.2. 方法二](#212-方法二)
    - [2.1.3. 方法三](#213-方法三)
  - [2.2. 快速排序](#22-快速排序)
    - [2.2.1. 递归](#221-递归)
    - [2.2.2. 非递归](#222-非递归)
  - [2.3. 插入排序](#23-插入排序)
  - [2.4. 冒泡排序](#24-冒泡排序)
  - [2.5. 选择排序](#25-选择排序)
  - [2.6. 归并排序](#26-归并排序)
    - [2.6.1. 递归](#261-递归)
    - [2.6.2. 非递归](#262-非递归)
  - [2.7. 堆排序](#27-堆排序)
- [3. 链表](#3-链表)
  - [3.1. 反转链表（头插法）](#31-反转链表头插法)
  - [3.2. 单链表去重](#32-单链表去重)
  - [3.3. 合并两个链表](#33-合并两个链表)
    - [3.3.1. 不创建临时结点](#331-不创建临时结点)
    - [3.3.2. 创建临时结点](#332-创建临时结点)
  - [3.4. 链表排序](#34-链表排序)
  - [3.5. 检查回文链表](#35-检查回文链表)
  - [3.6. 链表等概率随机抽取元素](#36-链表等概率随机抽取元素)
  - [3.7. 链表按奇数序号和偶数序号重排](#37-链表按奇数序号和偶数序号重排)
- [4. 二叉树遍历](#4-二叉树遍历)
  - [4.1. 二叉树前序遍历](#41-二叉树前序遍历)
    - [4.1.1. 递归](#411-递归)
    - [4.1.2. 非递归](#412-非递归)
  - [4.2. 二叉树中序遍历](#42-二叉树中序遍历)
    - [4.2.1. 递归](#421-递归)
    - [4.2.2. 非递归](#422-非递归)
  - [4.3. 二叉树后序遍历](#43-二叉树后序遍历)
    - [4.3.1. 递归](#431-递归)
    - [4.3.2. 非递归](#432-非递归)
  - [4.4. 二叉树层次遍历](#44-二叉树层次遍历)
- [5. 图](#5-图)
  - [5.1. Dijkstra算法](#51-dijkstra算法)
    - [5.1.1. 朴素](#511-朴素)
    - [5.1.2. 堆优化](#512-堆优化)
  - [5.2. Floyd-Warshall算法](#52-floyd-warshall算法)
  - [5.3. 拓扑排序](#53-拓扑排序)
    - [5.3.1. DFS](#531-dfs)
    - [5.3.2. BFS](#532-bfs)
- [6. 查找](#6-查找)
  - [6.1. 二分搜索](#61-二分搜索)
  - [6.2. 并查集](#62-并查集)
  - [6.3. Trie树](#63-trie树)
- [7. 回溯](#7-回溯)
  - [7.1. N皇后问题](#71-n皇后问题)
- [8. 栈与队列](#8-栈与队列)
  - [8.1. 栈模拟队列](#81-栈模拟队列)
  - [8.2. 队列模拟栈](#82-队列模拟栈)
- [9. 同步问题](#9-同步问题)
  - [9.1. 生产者——消费者模型](#91-生产者消费者模型)
- [10. 缓存策略](#10-缓存策略)
  - [10.1. LRU](#101-lru)
  - [10.2. LFU](#102-lfu)
- [11. 斐波拉契数列](#11-斐波拉契数列)
  - [11.1. 自顶向下](#111-自顶向下)
  - [11.2. 自底向上](#112-自底向上)
- [12. 经典题目](#12-经典题目)
  - [12.1. 计算数字二进制表示的1的个数](#121-计算数字二进制表示的1的个数)
  - [12.2. 数组中除一个数仅出现一次外，其他数均出现两次，找出这个数](#122-数组中除一个数仅出现一次外其他数均出现两次找出这个数)
  - [12.3. 长为n的数组中所有元素在\[1, n\]之间，元素最多出现两次，找出\[1, n\]中没出现的元素](#123-长为n的数组中所有元素在1-n之间元素最多出现两次找出1-n中没出现的元素)
  - [12.4. 不用`+`和`-`计算两个数的和](#124-不用和-计算两个数的和)
  - [12.5. 反转二叉树](#125-反转二叉树)
  - [12.6. 把数组中所有0移动到尾部，数组元素保持相对顺序不变](#126-把数组中所有0移动到尾部数组元素保持相对顺序不变)
  - [12.7. 定义一次move是将长为n的数组中n-1个数均加1，最少多少个move可以使得数组中所有元素相等](#127-定义一次move是将长为n的数组中n-1个数均加1最少多少个move可以使得数组中所有元素相等)
  - [12.8. 找出长为n的数组中出现次数大于⌊ n/2 ⌋的元素](#128-找出长为n的数组中出现次数大于⌊-n2-⌋的元素)
  - [12.9. 找出长为n的数组中出现次数大于⌊ n/k ⌋的元素](#129-找出长为n的数组中出现次数大于⌊-nk-⌋的元素)
  - [12.10. 十进制转换为7进制](#1210-十进制转换为7进制)
  - [12.11. 指定长度二进制数，指定1的个数的所有可能情况](#1211-指定长度二进制数指定1的个数的所有可能情况)
  - [12.12. 有序数组转二叉搜索树](#1212-有序数组转二叉搜索树)
  - [12.13. 最大连续子序列和](#1213-最大连续子序列和)
    - [12.13.1. 最小值为0](#12131-最小值为0)
    - [12.13.2. 最小值为负数](#12132-最小值为负数)
  - [12.14. 最大连续子序列积](#1214-最大连续子序列积)
  - [12.15. 判断一个数是否为2的幂次](#1215-判断一个数是否为2的幂次)
  - [12.16. 判断一个数是否为4的幂次](#1216-判断一个数是否为4的幂次)
  - [12.17. 最近公共祖先问题](#1217-最近公共祖先问题)
    - [12.17.1. 二叉树的最近公共祖先](#12171-二叉树的最近公共祖先)
    - [12.17.2. 二叉搜索树的最近公共祖先](#12172-二叉搜索树的最近公共祖先)
  - [12.18. 挑选数组中不连续的元素，使其和最大](#1218-挑选数组中不连续的元素使其和最大)
  - [12.19. 镜像二叉树](#1219-镜像二叉树)
  - [12.20. 判断二叉树是否平衡](#1220-判断二叉树是否平衡)
  - [12.21. 二分法求平方根](#1221-二分法求平方根)
  - [12.22. n!求末尾0的个数](#1222-n求末尾0的个数)
  - [12.23. 有序数组去重](#1223-有序数组去重)
  - [12.24. 链表判断环](#1224-链表判断环)
  - [12.25. 有环链表获取环起始结点](#1225-有环链表获取环起始结点)
  - [12.26. 判断是否为回文数](#1226-判断是否为回文数)
  - [12.27. 是否存在二叉树根到叶子节点路径和为指定值](#1227-是否存在二叉树根到叶子节点路径和为指定值)
  - [12.28. 找出字符串中所有变位词](#1228-找出字符串中所有变位词)
  - [12.29. 判断两个字符串是否为同构字符串](#1229-判断两个字符串是否为同构字符串)
  - [12.30. 判断一个数是否为其全部约数的和](#1230-判断一个数是否为其全部约数的和)
  - [12.31. 打乱数组元素](#1231-打乱数组元素)
  - [12.32. 生成不重复随机序列](#1232-生成不重复随机序列)
  - [12.33. 使用随机生成0到5的函数，实现随机生成0到7的函数](#1233-使用随机生成0到5的函数实现随机生成0到7的函数)
  - [12.34. 计算数组A、B、C、D中有多少种(i, j, k, l)使得A\[i\] + B\[j\] + C\[k\] + D\[l\] = 0](#1234-计算数组abcd中有多少种i-j-k-l使得ai--bj--ck--dl--0)
  - [12.35. 计算给出的多个时间中，最小的时间差](#1235-计算给出的多个时间中最小的时间差)
  - [12.36. 计算\[0, 10^n)中各位数字不同的数的个数](#1236-计算\0-10^n中各位数字不同的数的个数)
  - [12.37. 数组中仅有两个数仅出现一次，其余的数均出现两次，找出这两个数](#1237-数组中仅有两个数仅出现一次其余的数均出现两次找出这两个数)
  - [12.38. 找出递增数列中第n位的数字](#1238-找出递增数列中第n位的数字)
  - [12.39. 计算小于n的质数的个数](#1239-计算小于n的质数的个数)
  - [12.40. 由部分（可重复）给定数组元素相加得到指定值的情况数](#1240-由部分可重复给定数组元素相加得到指定值的情况数)
  - [12.41. 在有序矩阵中寻找第k大的数](#1241-在有序矩阵中寻找第k大的数)
  - [12.42. 求n对括号的所有排列情况](#1242-求n对括号的所有排列情况)
  - [12.43. 给定字符串数组，求最大不相交的两个字符串的长度积](#1243-给定字符串数组求最大不相交的两个字符串的长度积)
  - [12.44. 在由\[1, n\]组成的长为n + 1的数组中，寻找重复的那个数](#1244-在由1-n组成的长为n--1的数组中寻找重复的那个数)
  - [12.45. 求给定数组的所有排列情况](#1245-求给定数组的所有排列情况)
  - [12.46. 求给定（元素可重复）数组的所有排列情况](#1246-求给定元素可重复数组的所有排列情况)
  - [12.47. 最长回文子序列](#1247-最长回文子序列)
  - [12.48. 将\[1, n\]的数按字典排序](#1248-将1-n的数按字典排序)
  - [12.49. 二叉搜索树迭代器](#1249-二叉搜索树迭代器)
  - [12.50. 由\[1, n\]组成的二叉搜索树的个数](#1250-由1-n组成的二叉搜索树的个数)
  - [12.51. 格雷码](#1251-格雷码)
  - [12.52. 从m x n棋盘左上角走到右下角的路径总数](#1252-从m-x-n棋盘左上角走到右下角的路径总数)
  - [12.53. 求循环移位的有序数组中的到最小值](#1253-求循环移位的有序数组中的到最小值)
  - [12.54. 求集合的所有子集](#1254-求集合的所有子集)
  - [12.55. 求（元素可重复）集合的所有子集](#1255-求元素可重复集合的所有子集)
  - [12.56. 判断数组arr中是否存在arr\[i\] &lt; arr\[j\] &lt; arr\[k\]](#1256-判断数组arr中是否存在arri-lt-arrj-lt-arrk)
  - [12.57. 查找数组中第k大的数](#1257-查找数组中第k大的数)
  - [12.58. 链表删除倒数第n个结点](#1258-链表删除倒数第n个结点)
  - [12.59. 判断数组是否可以拼接为正方形](#1259-判断数组是否可以拼接为正方形)
  - [12.60. 快速`pow()`](#1260-快速pow)
  - [12.61. 判断数组是否可以分为相等的两部分](#1261-判断数组是否可以分为相等的两部分)
  - [12.62. 在矩阵中查找指定值](#1262-在矩阵中查找指定值)
  - [12.63. 将矩阵顺时针旋转90度](#1263-将矩阵顺时针旋转90度)
  - [12.64. 最长递增子序列](#1264-最长递增子序列)
  - [12.65. 求二维矩阵由左上角到右下角的最小和](#1265-求二维矩阵由左上角到右下角的最小和)
  - [12.66. 将由0、1、2组成的数组排序](#1266-将由012组成的数组排序)
  - [12.67. 求第n位仅由指定因数组成的数字](#1267-求第n位仅由指定因数组成的数字)
  - [12.68. 数组中查找极大值](#1268-数组中查找极大值)
  - [12.69. 判断n能否由平方数的和组成](#1269-判断n能否由平方数的和组成)
  - [12.70. 删除二叉搜索树中的结点](#1270-删除二叉搜索树中的结点)
  - [12.71. 检查字符串是否是合法的二叉树前序遍历结果](#1271-检查字符串是否是合法的二叉树前序遍历结果)
  - [12.72. 中缀表达式转后缀表达式](#1272-中缀表达式转后缀表达式)
  - [12.73. 排列的下一种情况](#1273-排列的下一种情况)
  - [12.74. 求旋转有序数组的最小值](#1274-求旋转有序数组的最小值)
  - [12.75. 在旋转有序数组中查找指定值](#1275-在旋转有序数组中查找指定值)
  - [12.76. 在旋转（元素可重复）有序数组中查找指定值](#1276-在旋转元素可重复有序数组中查找指定值)
  - [12.77. 有序数组中查找特定元素的第一个和最后一个索引](#1277-有序数组中查找特定元素的第一个和最后一个索引)
  - [12.78. 有序数组中查找指定值的插入位置](#1278-有序数组中查找指定值的插入位置)
  - [12.79. 实现`pow(x, n)`](#1279-实现powx-n)
  - [12.80. 第k个排列](#1280-第k个排列)
  - [12.81. 链表向右循环移动k个位置](#1281-链表向右循环移动k个位置)
  - [12.82. 先序遍历和中序遍历构建二叉树](#1282-先序遍历和中序遍历构建二叉树)
  - [12.83. 中序遍历和后序遍历构建二叉树](#1283-中序遍历和后序遍历构建二叉树)
  - [12.84. 求杨辉三角第k行的值](#1284-求杨辉三角第k行的值)
  - [12.85. 克隆图](#1285-克隆图)
  - [12.86. 查找数组中的极大值元素](#1286-查找数组中的极大值元素)
  - [12.87. 将数组合并拼接为最大的数](#1287-将数组合并拼接为最大的数)
  - [12.88. 计算完全二叉树的结点数](#1288-计算完全二叉树的结点数)
  - [12.89. 加减乘除（无括号）计算器](#1289-加减乘除无括号计算器)
  - [12.90. 加减（带括号）计算器](#1290-加减带括号计算器)
  - [12.91. 二叉搜索树中第k小的数](#1291-二叉搜索树中第k小的数)
  - [12.92. 求（元素可更新）数组指定区间的和](#1292-求元素可更新数组指定区间的和)
  - [12.93. 求数组中任意两个元素异或的最大值](#1293-求数组中任意两个元素异或的最大值)
  - [12.94. 二叉搜索树的序列化和反序列化](#1294-二叉搜索树的序列化和反序列化)
  - [12.95. 轮流取数判断先取者是否必胜](#1295-轮流取数判断先取者是否必胜)
  - [12.96. 一串数加上分别加上加号或减号使其结果等于指定值](#1296-一串数加上分别加上加号或减号使其结果等于指定值)
  - [12.97. 有序数组中除一个数仅出现一次外，其他数均出现两次，求这个数](#1297-有序数组中除一个数仅出现一次外其他数均出现两次求这个数)
  - [12.98. 最长任意元素差最大为1的子序列](#1298-最长任意元素差最大为1的子序列)
  - [12.99. 数组中寻找任意三个元素的最大积](#1299-数组中寻找任意三个元素的最大积)
  - [12.100. 快速替换10亿条标题中的5万个敏感词](#12100-快速替换10亿条标题中的5万个敏感词)
  - [12.101. 轮流取数的必胜策略](#12101-轮流取数的必胜策略)
  - [12.102. 最大公约数（辗转相除法）](#12102-最大公约数辗转相除法)
  - [12.103. 最小公倍数](#12103-最小公倍数)

<!-- /TOC -->

## 1. 单例模式

```java
public class Singleton {
    private volatile static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

## 2. 排序

### 2.1. 快速排序`partition`过程

#### 2.1.1. 方法一

```python
def partition(array, low, high):
    pivot = array[low]
    while low < high:
        while low < high and array[high] >= pivot:
            high -= 1
        array[low] = array[high]
        while low < high and array[low] <= pivot:
            low += 1
        array[high] = array[low]
    array[low] = pivot
    return low
```

#### 2.1.2. 方法二

```python
def partition2(array, low, high):
    def swap(array, i, j):
        array[i], array[j] = array[j], array[i]

    pivot = array[high]
    current = low
    for i in range(low, high):
        if array[i] < pivot:
            swap(array, i, current)
            current += 1
    swap(array, high, current)
    return current
```

#### 2.1.3. 方法三

```python
def partition3(array, low, high):
    def swap(array, i, j):
        array[i], array[j] = array[j], array[i]

    start = low
    pivot = array[low]
    low += 1
    while low <= high:
        while low <= high and array[low] <= pivot:
            low += 1
        while low <= high and array[high] >= pivot:
            high -= 1
        if low < high:
            swap(array, low, high)
    swap(array, start, high)
    return high
```

### 2.2. 快速排序

#### 2.2.1. 递归

```python
def quick_sort(array, low, high):
    if low >= high:
        return
    mid = partition(array, low, high)
    quick_sort(array, low, mid - 1)
    quick_sort(array, mid + 1, high)
```

#### 2.2.2. 非递归

```python
def quick_sort(array, low, high):
    stack = []
    stack.append(low)
    stack.append(high)
    while stack:
        high = stack.pop()
        low = stack.pop()
        if low >= high:
            continue
        mid = partition(array, low, high)
        stack.append(low)
        stack.append(mid - 1)
        stack.append(mid + 1)
        stack.append(high)
```

### 2.3. 插入排序

```python
def insertion_sort(array):
    for i in range(1, len(array)):
        temp = array[i]
        j = i - 1
        while j >= 0 and temp < array[j]:
            array[j + 1] = array[j]
            j -= 1
        array[j + 1] = temp
```

### 2.4. 冒泡排序

```python
def bubble_sort(array):
    def swap(array, i, j):
        array[i], array[j] = array[j], array[i]

    for j in range(len(array) - 1, 0, -1):
        flag = True
        for i in range(0, j):
            if array[i] > array[i + 1]:
                swap(array, i, i + 1)
                flag = False
        if flag:
            break
```

### 2.5. 选择排序

```python
def selection_sort(array):
    def swap(array, i, j):
        array[i], array[j] = array[j], array[i]

    for i in range(0, len(array) - 1):
        min_index = i
        for j in range(i + 1, len(array)):
            if array[j] < array[min_index]:
                min_index = j
        swap(array, i, min_index)
```

### 2.6. 归并排序

#### 2.6.1. 递归

```python
def merge(array, temp_array, low, mid, high):
    start1 = low
    end1 = mid
    start2 = mid + 1
    end2 = high
    k = low
    while start1 <= end1 and start2 <= end2:
        if array[start1] < array[start2]:
            temp_array[k] = array[start1]
            start1 += 1
        else:
            temp_array[k] = array[start2]
            start2 += 1
        k += 1
    while start1 <= end1:
        temp_array[k] = array[start1]
        start1 += 1
        k += 1
    while start2 <= end2:
        temp_array[k] = array[start2]
        start2 += 1
        k += 1
    for k in range(low, high + 1):
        array[k] = temp_array[k]


def merge_sort_real(array, temp_array, low, high):
    if low >= high:
        return
    mid = (low + high) // 2
    merge_sort_real(array, temp_array, low, mid)
    merge_sort_real(array, temp_array, mid + 1, high)
    merge(array, temp_array, low, mid, high)


def merge_sort(array):
    merge_sort_real(array, [0] * len(array), 0, len(array) - 1)
```

#### 2.6.2. 非递归

```python
def merge_sort(array):
    length = len(array)
    temp_array = [0] * length
    block = 1
    while block < length * 2:
        for start in range(0, length, 2 * block):
            low = start
            mid = (start + block) if (start + block) < length else length
            high = (start + 2 * block) if (start + 2 * block) < length else length
            start1 = low
            end1 = mid
            start2 = mid
            end2 = high
            k = low
            while start1 < end1 and start2 < end2:
                if array[start1] < array[start2]:
                    temp_array[k] = array[start1]
                    start1 += 1
                else:
                    temp_array[k] = array[start2]
                    start2 += 1
                k += 1
            while start1 < end1:
                temp_array[k] = array[start1]
                start1 += 1
                k += 1
            while start2 < end2:
                temp_array[k] = array[start2]
                start2 += 1
                k += 1
        array, temp_array = temp_array, array
        block *= 2
```

### 2.7. 堆排序

```python
def heap_sort(array):
    def swap(array, i, j):
        array[i], array[j] = array[j], array[i]

    def shift_down(start, end):
        root = start
        while True:
            child = 2 * root + 1
            if child > end:
                break
            if child + 1 <= end and array[child] < array[child + 1]:
                child += 1
            if array[root] < array[child]:
                swap(array, root, child)
                root = child
            else:
                break

    def build_heap(array):
        length = len(array)
        for start in range((length - 1) // 2, -1, -1):
            shift_down(start, length - 1)

    build_heap(array)
    for end in range(len(array) - 1, 0, -1):
        swap(array, 0, end)
        shift_down(0, end - 1)
```

## 3. 链表

### 3.1. 反转链表（头插法）

```python
def reverse_list(head):
    if not head:
        return head
    new_head = head
    while head.next:
        current = head.next
        head.next = head.next.next
        current.next = new_head
        new_head = current
    return new_head
```

### 3.2. 单链表去重

```java
public ListNode deleteDuplicates(ListNode head) {
    ListNode p = head;
    while (p != null) {
        if (p.next != null && p.next.val == p.val) {
            p.next = p.next.next;
        } else {
            p = p.next;
        }
    }
    return head;
}
```

### 3.3. 合并两个链表

#### 3.3.1. 不创建临时结点

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    if (l1 == null) {
        return l2;
    }
    if (l2 == null) {
        return l1;
    }
    if (l1.val > l2.val) {
        ListNode temp = l1;
        l1 = l2;
        l2 = temp;
    }
    ListNode p = l1;
    while (p != null) {
        while (l2 != null && (p.next == null || l2.val < p.next.val)) {
            ListNode temp = l2;
            l2 = l2.next;
            temp.next = p.next;
            p.next = temp;
            p = p.next;
        }
        p = p.next;
    }
    return l1;
}
```

#### 3.3.2. 创建临时结点

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode fakeHead = new ListNode(0);
    ListNode tail = fakeHead;
    while (l1 != null && l2 != null) {
        if (l1.val < l2.val) {
            tail.next = l1;
            l1 = l1.next;
        } else {
            tail.next = l2;
            l2 = l2.next;
        }
        tail = tail.next;
    }
    tail.next = l1 == null ? l2 : l1;
    return fakeHead.next;
}
```

### 3.4. 链表排序

```python
def sortList(self, head):
    """
    :type head: ListNode
    :rtype: ListNode
    """
    if not head or not head.next:
        return head
    slow = head
    fast = head
    prev = None
    while fast and fast.next:
        prev = slow
        slow = slow.next
        fast = fast.next.next
    prev.next = None
    a = sortList(head)
    b = sortList(slow)
    fake_head = ListNode(0)
    temp = fake_head
    while a and b:
        if a.val < b.val:
            temp.next = a
            a = a.next
        else:
            temp.next = b
            b = b.next
        temp = temp.next
    if a:
        temp.next = a
    else:
        temp.next = b
    return fake_head.next
```

### 3.5. 检查回文链表

```python
def isPalindrome(head):
    """
    :type head: ListNode
    :rtype: bool
    """
    if not head or not head.next:
        return True
    slow = head
    fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    temp = None
    while slow:
        next = slow.next
        slow.next = temp
        temp = slow
        slow = next
    slow = temp
    while head and slow:
        if head.val != slow.val:
            return False
        head = head.next
        slow = slow.next
    return True
```

### 3.6. 链表等概率随机抽取元素

```java
public int getRandom(ListNode head) {
    ListNode node = head;
    int result = -1;
    int count = 1;
    Random random = new Random();
    while (node != null) {
        if (random.nextInt(count) == 0) {
            result = node.val;
        }
        count++;
        node = node.next;
    }
    return result;
}
```

### 3.7. 链表按奇数序号和偶数序号重排

```python
def oddEvenList(head):
    """
    :type head: ListNode
    :rtype: ListNode
    """
    if not head:
        return None
    odd = head
    even = head.next
    even_head = even
    while even and even.next:
        odd.next = odd.next.next
        even.next = even.next.next
        odd = odd.next
        even = even.next
    odd.next = even_head
    return head
```

## 4. 二叉树遍历

### 4.1. 二叉树前序遍历

#### 4.1.1. 递归

```python
def pre_order(root):
    if root:
        print(root.val)
        pre_order(root.left)
        pre_order(root.right)
```

#### 4.1.2. 非递归

```python
def pre_order(root):
    stack = []
    while root or stack:
        if root:
            print(root.val)
            stack.append(root)
            root = root.left
        else:
            node = stack.pop()
            root = node.right
```

### 4.2. 二叉树中序遍历

#### 4.2.1. 递归

```python
def in_order(root):
    if root:
        in_order(root.left)
        print(root.val)
        in_order(root.right)
```

#### 4.2.2. 非递归

```python
def in_order(root):
    stack = []
    while root or stack:
        if root:
            stack.append(root)
            root = root.left
        else:
            node = stack.pop()
            print(node.val)
            root = node.right
```

### 4.3. 二叉树后序遍历

#### 4.3.1. 递归

```python
def post_order(root):
    if root:
        post_order(root.left)
        post_order(root.right)
        print(root.val)
```

#### 4.3.2. 非递归

```python
def post_order(root):
    stack = []
    result = []
    node = root
    while node or stack:
        if node:
            stack.append(node)
            result.append(node.val)
            node = node.right
        else:
            node = stack.pop()
            node = node.left
    result.reverse()
    return result
```

### 4.4. 二叉树层次遍历

```python
def level_order(root):
    if not root:
        return
    queue = collections.deque()
    queue.append(root)
    while queue:
        size = len(queue)
        for i in range(size):
            node = queue.popleft()
            print(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
```

## 5. 图

### 5.1. Dijkstra算法

#### 5.1.1. 朴素

```python
def dijkstra(start, end, graph, n):
    """
    :param start: int, [1,n]
    :param end: int, [1,n]
    :param graph: dict, {from: (to, distance), from: (to, distance)...}
    :param n: int
    :return: (int, list), minimum distance, path
    """
    d = [sys.maxsize] * (n + 1)
    previous = [None] * (n + 1)
    d[start] = 0
    candidates = set(i for i in range(1, n + 1))
    while candidates:
        min_d = sys.maxsize
        u = -1
        for candidate in candidates:
            if min_d > d[candidate]:
                min_d = d[candidate]
                u = candidate
        if u == end:
            return d[u], previous
        candidates.remove(u)
        for v, dist in graph[u]:
            if d[v] > d[u] + dist:
                d[v] = d[u] + dist
                previous[v] = u
```

#### 5.1.2. 堆优化

```python
def dijkstra(start, end, graph, n):
    """
    :param start: int, [1,n]
    :param end: int, [1,n]
    :param graph: dict, {from: (to, distance), from: (to, distance)...}
    :param n: int
    :return: (int, list), minimum distance, path
    """
    d = [sys.maxsize] * (n + 1)
    previous = [None] * (n + 1)
    d[start] = 0
    candidates = set(i for i in range(1, n + 1))
    heap = []
    heapq.heappush(heap, (0, start))
    while candidates:
        distance, u = heapq.heappop()
        if u == end:
            return d[u], previous
        if u not in candidates:
            continue
        candidates.remove(u)
        for v, dist in graph[u]:
            if d[v] > d[u] + dist:
                d[v] = d[u] + dist
                heapq.heappush(heap, (d[v], v))
                previous[v] = u
```

### 5.2. Floyd-Warshall算法

```python
def floyd_warshall(graph, n):
    INF = 10000
    dist = [[INF] * n for _ in range(n)]
    path = [[-1] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if i == j:
                dist[i][j] = 0
            elif graph[i][j] < INF:
                dist[i][j] = graph[i][j]
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][j] > dist[i][k] + dist[k][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
                    path[i][j] = k
    return dist, path
```

### 5.3. 拓扑排序

#### 5.3.1. DFS

```python
def topological_sort(graph, n):
    order = []
    visiting = [False] * n
    visited = [False] * n
    for i in range(n):
        if not visited[i]:
            if not dfs(graph, i, visiting, visited, order):
                raise ValueError('cycle')
    order.reverse()
    return order


def dfs(graph, index, visiting, visited, order):
    visiting[index] = True
    visited[index] = True
    for neighbor in graph[index]:
        if visiting[neighbor]:
            return False
        if not visited[neighbor]:
            if not dfs(graph, neighbor, visiting, visited, order):
                return False
    order.append(index)
    visiting[index] = False
    return True
```

#### 5.3.2. BFS

```python
def topological_sort(graph, n):
    in_degrees = [0] * n
    for i in range(n):
        for index in graph[i]:
            in_degrees[index] += 1
    candidates = set()
    for i in range(n):
        if in_degrees[i] == 0:
            candidates.add(i)
    order = []
    while candidates:
        index = candidates.pop()
        order.append(index)
        for neighbor in graph[index]:
            in_degrees[neighbor] -= 1
            if in_degrees[neighbor] == 0:
                candidates.add(neighbor)
    if len(order) != n:
        raise ValueError('cycle')
    return order
```

## 6. 查找

### 6.1. 二分搜索

```python
def binary_search(array, key):
    low = 0
    high = len(array) - 1
    while low <= high:
        mid = (low + high) // 2
        if array[mid] == key:
            return mid
        elif array[mid] > key:
            high = mid - 1
        else:
            low = mid + 1
    return -1
```

### 6.2. 并查集

```python
class UnionFind:
    def __init__(self, n):
        self.count = n
        self.parent = [i for i in range(n)]
        self.rank = [0] * n

    def find(self, num):
        if num != self.parent[num]:
            self.parent[num] = self.find(self.parent[num])
        return self.parent[num]

    def union(self, a, b):
        parent_a = self.find(a)
        parent_b = self.find(b)
        if parent_a == parent_b:
            return
        if self.rank[parent_a] > self.rank[parent_b]:
            self.parent[parent_b] = parent_a
        else:
            self.parent[parent_a] = parent_b
            if self.rank[parent_a] == self.rank[parent_b]:
                self.rank[parent_b] += 1
        self.count -= 1
```

### 6.3. Trie树

```java
public class Trie {
    TrieNode root;

    class TrieNode {
        boolean isWord = false;
        char val;
        TrieNode[] children = new TrieNode[26];
    }

    public Trie() {
        root = new TrieNode();
    }

    public void insert(String word) {
        TrieNode current = root;
        for (char letter : word.toCharArray()) {
            if (current.children[letter - 'a'] == null) {
                current.children[letter - 'a'] = new TrieNode();
                current.children[letter - 'a'].val = letter;
            }
            current = current.children[letter - 'a'];
        }
        current.isWord = true;
    }

    public boolean search(String word) {
        TrieNode current = root;
        for (char letter : word.toCharArray()) {
            if (current.children[letter - 'a'] == null) {
                return false;
            }
            current = current.children[letter - 'a'];
        }
        return current.isWord;
    }

    public boolean startsWith(String prefix) {
        TrieNode current = root;
        for (char letter : prefix.toCharArray()) {
            if (current.children[letter - 'a'] == null) {
                return false;
            }
            current = current.children[letter - 'a'];
        }
        return true;
    }
}
```

## 7. 回溯

### 7.1. N皇后问题

```python
def n_queens(n):
    """
    :type n: int
    :rtype: List[List[str]]
    """
    board = [['.'] * n for _ in range(n)]
    result = []
    back_trace(board, 0, result)
    return result


def back_trace(board, row_index, result):
    if row_index == len(board):
        result.append(convert(board))
        return
    for j in range(len(board[row_index])):
        if is_valid(board, row_index, j):
            board[row_index][j] = 'Q'
            back_trace(board, row_index + 1, result)
            board[row_index][j] = '.'


def convert(board):
    return [''.join(row) for row in board]


def is_valid(board, i, j):
    for x in range(i):
        for y in range(len(board[i])):
            if board[x][y] == 'Q' and (y == j or i - x == j - y or i - x == y - j):
                return False
    return True
```

## 8. 栈与队列

### 8.1. 栈模拟队列

```java
public class MyQueue {
    Stack<Integer> stackA;
    Stack<Integer> stackB;

    public MyQueue() {
        stackA = new Stack<>();
        stackB = new Stack<>();
    }

    public void push(int x) {
        stackA.add(x);
    }

    public int pop() {
        if (stackB.empty()) {
            while (!stackA.empty()) {
                stackB.add(stackA.pop());
            }
        }
        return stackB.pop();
    }

    public int peek() {
        if (stackB.empty()) {
            while (!stackA.empty()) {
                stackB.add(stackA.pop());
            }
        }
        return stackB.peek();
    }

    public boolean empty() {
        return stackA.empty() && stackB.empty();
    }
}
```

### 8.2. 队列模拟栈

```java
public class MyStack {
    Queue<Integer> queue;

    public MyStack() {
        queue = new LinkedList<>();
    }

    public void push(int x) {
        queue.add(x);
        for (int i = 0; i < queue.size() - 1; i++) {
            queue.add(queue.poll());
        }
    }

    public int pop() {
        return queue.poll();
    }

    public int top() {
        return queue.peek();
    }

    public boolean empty() {
        return queue.isEmpty();
    }
}
```

## 9. 同步问题

### 9.1. 生产者——消费者模型

```java
public class Main {
    public static void main(String[] args) {
        Queue<Integer> queue = new LinkedList<>();
        int maxSize = 10;
        Thread producer1 = new Producer(queue, maxSize, "Producer 1");
        Thread producer2 = new Producer(queue, maxSize, "Producer 2");
        Thread consumer1 = new Consumer(queue, "Consumer 1");
        Thread consumer2 = new Consumer(queue, "Consumer 2");

        producer1.start();
        consumer1.start();
        producer2.start();
        consumer2.start();
    }

    static class Producer extends Thread {
        Queue<Integer> queue;
        int maxSize;
        Random random;

        public Producer(Queue<Integer> queue, int maxSize, String name) {
            super(name);
            this.queue = queue;
            this.maxSize = maxSize;
            random = new Random();
        }

        @Override
        public void run() {
            while (true) {
                try {
                    produce();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }

        void produce() throws InterruptedException {
            synchronized (queue) {
                while (queue.size() == maxSize) {
                    System.out.println("Queue is full, " + this.getName() + " is waiting");
                    queue.wait();
                }
                int item = random.nextInt();
                queue.add(item);
                System.out.println(this.getName() + " produced " + item + ", queue size is " + queue.size() + " now");
                queue.notifyAll();
                Thread.sleep(new Random().nextInt(1000));
            }
        }
    }

    static class Consumer extends Thread {
        Queue<Integer> queue;
        Random random;

        public Consumer(Queue<Integer> queue, String name) {
            super(name);
            this.queue = queue;
            random = new Random();
        }

        @Override
        public void run() {
            while (true) {
                try {
                    consume();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }

        void consume() throws InterruptedException {
            synchronized (queue) {
                while (queue.isEmpty()) {
                    System.out.println("Queue is empty, " + this.getName() + " is waiting");
                    queue.wait();
                }
                int item = queue.remove();
                System.out.println(this.getName() + " consumed " + item + ", queue size is " + queue.size() + " now");
                queue.notifyAll();
                Thread.sleep(new Random().nextInt(1000));
            }
        }
    }
}
```

## 10. 缓存策略

### 10.1. LRU

```python
class LRUCache:
    class Node:
        def __init__(self, key, value):
            self.key = key
            self.val = value
            self.prev = None
            self.next = None

    def __init__(self, capacity):
        """
        :type capacity: int
        """
        self.capacity = capacity
        self.memory = {}
        self.head = self.Node(-1, -1)
        self.tail = self.Node(-1, -1)
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key):
        """
        :type key: int
        :rtype: int
        """
        if key not in self.memory:
            return -1
        node = self.memory[key]
        self.to_head(node)
        return node.val

    def put(self, key, value):
        """
        :type key: int
        :type value: int
        :rtype: void
        """
        if key in self.memory:
            node = self.memory[key]
            node.val = value
            self.to_head(node)
        else:
            if len(self.memory) == self.capacity:
                del self.memory[self.tail.prev.key]
                self.remove(self.tail.prev)
            node = self.Node(key, value)
            self.memory[key] = node
            self.add(node)

    def to_head(self, node):
        self.remove(node)
        self.add(node)

    def remove(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

    def add(self, node):
        node.next = self.head.next
        self.head.next = node
        node.prev = self.head
        node.next.prev = node
```

### 10.2. LFU

```python
class LFUCache:
    class Node:
        def __init__(self, key, value, times):
            self.key = key
            self.value = value
            self.times = times
            self.prev = None
            self.next = None

    def __init__(self, capacity):
        """
        :type capacity: int
        """
        self.init_capacity = capacity
        self.capacity = capacity
        self.memory_nodes = {}
        self.memory_times = {}
        self.head = self.Node(-1, -1, -1)
        self.tail = self.Node(-1, -1, -1)
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key):
        """
        :type key: int
        :rtype: int
        """
        if key not in self.memory_nodes:
            return -1
        self.put(key, self.memory_nodes[key].value)
        return self.memory_nodes[key].value

    def put(self, key, value):
        """
        :type key: int
        :type value: int
        :rtype: void
        """
        if self.init_capacity == 0:
            return
        if key in self.memory_nodes:
            node = self.memory_nodes[key]
            node.value = value

            if node.times + 1 in self.memory_times:
                if self.memory_times[node.times] == node:
                    if node.next.times == node.times:
                        self.memory_times[node.times] = node.next
                    else:
                        del self.memory_times[node.times]
                node.prev.next = node.next
                node.next.prev = node.prev
                node.prev = self.memory_times[node.times + 1].prev
                node.next = self.memory_times[node.times + 1]
                node.next.prev = node
                node.prev.next = node
                self.memory_times[node.times + 1] = node
            else:
                if self.memory_times[node.times] != node:
                    node.prev.next = node.next
                    node.next.prev = node.prev
                    node.prev = self.memory_times[node.times].prev
                    node.next = self.memory_times[node.times]
                    node.next.prev = node
                    node.prev.next = node
                else:
                    if node.next.times == node.times:
                        self.memory_times[node.times] = node.next
                    else:
                        del self.memory_times[node.times]
                self.memory_times[node.times + 1] = node
            node.times += 1
        else:
            node = self.Node(key, value, 1)
            self.memory_nodes[key] = node
            if self.capacity == 0:
                node_to_remove = self.tail.prev
                if self.memory_times[node_to_remove.times] == node_to_remove:
                    del self.memory_times[node_to_remove.times]
                node_to_remove.prev.next = node_to_remove.next
                node_to_remove.next.prev = node_to_remove.prev
                del self.memory_nodes[node_to_remove.key]
                self.capacity += 1
            if 1 in self.memory_times:
                node.prev = self.memory_times[1].prev
                node.next = self.memory_times[1]

            else:
                node.prev = self.tail.prev
                node.next = self.tail
            node.next.prev = node
            node.prev.next = node
            self.memory_times[1] = node
            self.capacity -= 1
```

## 11. 斐波拉契数列

### 11.1. 自顶向下

```python
def fibonacci(n):
    if n == 1 or n == 2:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)
```

### 11.2. 自底向上

```python
def fibonacci(n):
    a = 1
    b = 1
    n -= 2
    while n > 0:
        temp = a + b
        a = b
        b = temp
        n -= 1
    return b
```

## 12. 经典题目

### 12.1. 计算数字二进制表示的1的个数

[Leetcode 461. Hamming Distance][leetcode_461]

```python
def count_1s(num):
    count = 0
    while num:
        num &= (num - 1)
        count += 1
    return count
```

### 12.2. 数组中除一个数仅出现一次外，其他数均出现两次，找出这个数

[Leetcode 136. Single Number][leetcode_136]

```python
def single_number(nums):
    result = 0
    for num in nums:
        result ^= num
    return result
```

### 12.3. 长为n的数组中所有元素在[1, n]之间，元素最多出现两次，找出[1, n]中没出现的元素

[Leetcode 448. Find All Numbers Disappeared in an Array][leetcode_448]

```python
def find_disappeared_numbers(nums):
    """
    :type nums: List[int]
    :rtype: List[int]
    """
    for num in nums:
        index = num if num > 0 else -num
        index -= 1
        if nums[index] > 0:
            nums[index] = -nums[index]
    result = []
    for (index, num) in enumerate(nums):
        if num > 0:
            result.append(index + 1)
    return result
```

### 12.4. 不用`+`和`-`计算两个数的和

[Leetcode 371. Sum of Two Integers][leetcode_371]

```java
public int getSum(int a, int b) {
    int sum = a ^ b;
    int part = a & b;
    while (part != 0) {
        int theA = sum;
        int theB = part << 1;
        sum = theA ^ theB;
        part = theA & theB;
    }
    return sum;
}
```

### 12.5. 反转二叉树

[Leetcode 226. Invert Binary Tree][leetcode_226]

```python
def invertTree(root):
    """
    :type root: TreeNode
    :rtype: TreeNode
    """
    if root is None:
        return
    self.invertTree(root.left)
    self.invertTree(root.right)
    temp = root.left
    root.left = root.right
    root.right = temp
    return root
```

### 12.6. 把数组中所有0移动到尾部，数组元素保持相对顺序不变

[Leetcode 283. Move Zeroes][leetcode_283]

```java
void moveZeroes(int[] nums) {
    int currentIndex = 0;
    for (int num : nums) {
        if (num != 0) nums[currentIndex] = num;
        currentIndex++;
    }
    while (currentIndex < nums.length) {
        nums[currentIndex] = 0;
        currentIndex++;
    }
}
```

### 12.7. 定义一次move是将长为n的数组中n-1个数均加1，最少多少个move可以使得数组中所有元素相等

[Leetcode 453. Minimum Moves to Equal Array Elements][leetcode_453]

```python
def minMoves(nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    return sum(nums) - min(nums) * len(nums)
```

### 12.8. 找出长为n的数组中出现次数大于⌊ n/2 ⌋的元素

[Leetcode 169. Majority Element][leetcode_169]

```python
def majorityElement(nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    majority = None
    count = 0
    for num in nums:
        if count == 0:
            majority = num
        if majority == num:
            count += 1
        else:
            count -= 1
    return majority
```

### 12.9. 找出长为n的数组中出现次数大于⌊ n/k ⌋的元素

```python
def majority_element(nums, k):
    counters = {}
    for num in nums:
        if num in counters:
            counters[num] += 1
        elif len(counters.keys()) < k - 1:
            counters[num] = 1
        else:
            for key, count in counters.items():
                if count == 1:
                    del counters[key]
                else:
                    counters[key] -= 1
    for num in counters.keys():
        counters[num] = 0
    for num in nums:
        if num in counters:
            counters[num] += 1
    target = len(nums) // k
    result = []
    for num, count in counters.items():
        if count > target:
            result.append(num)
    return result
```

### 12.10. 十进制转换为7进制

[Leetcode 504. Base 7][leetcode_504]

```java
public String convertToBase7(int num) {
    if (num == 0) {
        return "0";
    }
    int sign = num >= 0 ? 1 : -1;
    num = Math.abs(num);
    StringBuilder builder = new StringBuilder();
    while (num != 0) {
        builder.append(num % 7);
        num /= 7;
    }
    if (sign < 0) {
        builder.append('-');
    }
    return builder.reverse().toString();
}
```

### 12.11. 指定长度二进制数，指定1的个数的所有可能情况

[Leetcode 401. Binary Watch][leetcode_401]

```python
def get_combination(length, num_ones):
    def combination(length, num_ones, base, result):
        if num_ones == 0:
            result.append(base)
            return
        if length == 0 or length < num_ones:
            return
        combination(length - 1, num_ones - 1, base + (1 << (length - 1)), result)
        combination(length - 1, num_ones, base, result)

    result = []
    combination(length, num_ones, 0, result)
    return result
```

### 12.12. 有序数组转二叉搜索树

[Leetcode 108. Convert Sorted Array to Binary Search Tree][leetcode_108]

```java
TreeNode toBST(int[] nums, int start, int end) {
    if (start > end) {
        return null;
    }
    int mid = (start + end) / 2;
    TreeNode node = new TreeNode(nums[mid]);
    node.left = toBST(nums, start, mid - 1);
    node.right = toBST(nums, mid + 1, end);
    return node;
}

public TreeNode sortedArrayToBST(int[] nums) {
    if (nums.length == 0) {
        return null;
    }
    return toBST(nums, 0, nums.length - 1);
}
```

### 12.13. 最大连续子序列和

[Leetcode 121. Best Time to Buy and Sell Stock][leetcode_121]

#### 12.13.1. 最小值为0

```python
def max_subarray(nums):
    max_ending_here = 0
    max_so_far = 0
    for x in nums:
        max_ending_here = max(0, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far
```

#### 12.13.2. 最小值为负数

```python
def max_subarray(nums):
    max_ending_here = nums[0]
    max_so_far = nums[0]
    for x in nums[1:]:
        max_ending_here = max(x, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far
```

### 12.14. 最大连续子序列积

[Leetcode 152. Maximum Product Subarray][leetcode_152]

```python
def maxProduct(self, nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    if not nums:
        return 0
    max_here = nums[0]
    min_here = nums[0]
    max_so_far = nums[0]
    for num in nums[1:]:
        max_here *= num
        min_here *= num
        max_here, min_here = max(max_here, min_here, num), min(max_here, min_here, num)
        max_so_far = max(max_here, max_so_far)
    return max_so_far
```

### 12.15. 判断一个数是否为2的幂次

[Leetcode 231. Power of Two][leetcode_231]

```python
def isPowerOfTwo(n):
    """
    :type n: int
    :rtype: bool
    """
    return n > 0 and 0x80000000 % n == 0
```

### 12.16. 判断一个数是否为4的幂次

[Leetcode 342. Power of Four][leetcode_342]

```python
def isPowerOfFour(num):
    """
    :type num: int
    :rtype: bool
    """
    return num > 0 and num & (num - 1) == 0 and num & 0x55555555 == num
```

### 12.17. 最近公共祖先问题

#### 12.17.1. 二叉树的最近公共祖先

[Leetcode 236. Lowest Common Ancestor of a Binary Tree][leetcode_236]

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) {
        return root;
    }
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    if (left != null && right != null) {
        return root;
    }
    return left == null ? right : left;
}
```

#### 12.17.2. 二叉搜索树的最近公共祖先

[Leetcode 235. Lowest Common Ancestor of a Binary Search Tree][leetcode_235]

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    while (root != null) {
        if ((p.val < root.val && q.val > root.val)
            || (p.val > root.val && q.val < root.val)
            || p.val == root.val || q.val == root.val) {
            return root;
        }
        if (p.val < root.val && q.val < root.val) {
            root = root.left;
        }
        if (p.val > root.val && q.val > root.val) {
            root = root.right;
        }
    }
    return null;
}
```

### 12.18. 挑选数组中不连续的元素，使其和最大

[Leetcode 198. House Robber][leetcode_198]

```java
public int rob(int[] nums) {
    if (nums.length == 0) {
        return 0;
    }
    int[] results = new int[nums.length + 1];
    results[0] = 0;
    results[1] = nums[0];
    for (int i = 2; i <= nums.length; i++) {
        results[i] = Math.max(nums[i - 1] + results[i - 2], results[i - 1]);
    }
    return results[nums.length];
}
```

### 12.19. 镜像二叉树

[Leetcode 101. Symmetric Tree][leetcode_101]

```python
def isSymmetric(root):
    """
    :type root: TreeNode
    :rtype: bool
    """

    def symmetric(left, right):
        if not left and not right:
            return True
        if left and right and left.val == right.val:
            return symmetric(left.left, right.right) and symmetric(left.right, right.left)
        return False

    if not root:
        return True
    return symmetric(root.left, root.right)
```

### 12.20. 判断二叉树是否平衡

[Leetcode 110. Balanced Binary Tree][leetcode_110]

```python
def isBalanced(root):
    """
    :type root: TreeNode
    :rtype: bool
    """

    def balanced(root):
        if not root:
            return 0
        left = balanced(root.left)
        right = balanced(root.right)
        if left == -1 or right == -1 or abs(left - right) > 1:
            return -1
        return 1 + max(left, right)

    return balanced(root) != -1
```

### 12.21. 二分法求平方根

[Leetcode 367. Valid Perfect Square][leetcode_367]

```java
public int mySqrt(int x) {
    if (x == 0) {
        return 0;
    }
    int low = 1;
    int high = x;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (mid <= x / mid) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return low - 1;
}
```

### 12.22. n!求末尾0的个数

[Leetcode 172. Factorial Trailing Zeroes][leetcode_172]

```java
public int trailingZeroes(int n) {
    int result = 0;
    long i = 5;
    while (i <= n) {
        result += n / i;
        i *= 5;
    }
    return result;
}
```

### 12.23. 有序数组去重

[Leetcode 26. Remove Duplicates from Sorted Array][leetcode_26]

```python
def removeDuplicates(self, nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    if not nums:
        return 0
    i = 0
    for j in range(1, len(nums)):
        if nums[j] != nums[i]:
            i += 1
            nums[i] = nums[j]
    return i + 1
```

### 12.24. 链表判断环

[Leetcode 141. Linked List Cycle][leetcode_141]

```python
def hasCycle(head):
    """
    :type head: ListNode
    :rtype: bool
    """
    if head is None or head.next is None:
        return False
    walker = head
    runner = head.next
    while runner.next and runner.next.next:
        walker = walker.next
        runner = runner.next.next
        if walker == runner:
            return True
    return False
```

### 12.25. 有环链表获取环起始结点

[Leetcode 142. Linked List Cycle II][leetcode_142]

### 12.26. 判断是否为回文数

[Leetcode 9. Palindrome Number][leetcode_9]

```java
public boolean isPalindrome(int x) {
    if (x == 0) {
        return true;
    }
    if (x < 0 || x % 10 == 0) {
        return false;
    }
    int palindrome = 0;
    while (palindrome < x) {
        palindrome = palindrome * 10 + x % 10;
        x /= 10;
    }
    return x == palindrome || x == palindrome / 10;
}
```

### 12.27. 是否存在二叉树根到叶子节点路径和为指定值

[Leetcode 112. Path Sum][leetcode_112]

```python
def hasPathSum(root, sum):
    """
    :type root: TreeNode
    :type sum: int
    :rtype: bool
    """
    if root is None:
        return False
    if root.val == sum and root.left is None and root.right is None:
        return True

    return hasPathSum(root.left, sum - root.val) or hasPathSum(root.right, sum - root.val)
```

### 12.28. 找出字符串中所有变位词

[Leetcode 438. Find All Anagrams in a String][leetcode_438]

```java
public List<Integer> findAnagrams(String s, String p) {
    List<Integer> list = new ArrayList<>();
    if (s == null || s.length() == 0 || p == null || p.length() == 0) return list;
    int[] hash = new int[256];
    for (char c : p.toCharArray()) {
        hash[c]++;
    }
    int left = 0, right = 0, count = p.length();
    while (right < s.length()) {
        if (hash[s.charAt(right)] >= 1) {
            count--;
        }
        hash[s.charAt(right)]--;
        right++;
        if (count == 0) {
            list.add(left);
        }
        if (right - left == p.length()) {
            if (hash[s.charAt(left)] >= 0) {
                count++;
            }
            hash[s.charAt(left)]++;
            left++;
        }
    }
    return list;
}
```

### 12.29. 判断两个字符串是否为同构字符串

[Leetcode 205. Isomorphic Strings][leetcode_205]

```java
public boolean isIsomorphic(String s, String t) {
    int[] m1 = new int[256];
    int[] m2 = new int[256];
    for (int i = 0; i < s.length(); i++) {
        char k1 = s.charAt(i);
        char k2 = t.charAt(i);
        if (m1[k1] != m2[k2]) {
            return false;
        }
        m1[k1] = i + 1;
        m2[k2] = i + 1;
    }
    return true;
}
```

### 12.30. 判断一个数是否为其全部约数的和

[Leetcode 507. Perfect Number][leetcode_507]

```python
def checkPerfectNumber(num):
    """
    :type num: int
    :rtype: bool
    """
    if num == 1:
        return False
    result = 0
    i = 2
    while i * i <= num:
        if num % i == 0:
            result += i
            result += num // i
        i += 1
    result += 1
    return result == num
```

### 12.31. 打乱数组元素

[Leetcode 384. Shuffle an Array][leetcode_384]

```java
public void shuffle(int[] nums) {
    int length = nums.length;
    Random random = new Random();
    for (int i = 0; i < length; i++) {
        int swapIndex = random.nextInt(length);
        int temp = nums[i];
        nums[i] = nums[swapIndex];
        nums[swapIndex] = temp;
    }
    return nums;
}
```

### 12.32. 生成不重复随机序列

```java
Random random = new Random();

public int[] randomSequence(int n) {
    int[] sequence = new int[n];
    int[] result = new int[n];
    for (int i = 0; i < n; i++) {
        sequence[i] = i;
    }
    int last = n - 1;
    for (int i = 0; i < n; i++) {
        int index = random.nextInt(last + 1);
        result[i] = sequence[index];
        sequence[index] = sequence[last];
        last--;
    }
    return result;
}
```

### 12.33. 使用随机生成0到5的函数，实现随机生成0到7的函数

```java
Random random = new Random();

int random5(){
    return random.nextInt(6);
}
int random7(){
    while(true){
        int temp1=random5();
        int temp2=random5();
        int n=temp1*6+temp2;
        if(n<8){
            return n;
        }
    }
}
```

### 12.34. 计算数组A、B、C、D中有多少种(i, j, k, l)使得A[i] + B[j] + C[k] + D[l] = 0

[Leetcode 454. 4Sum II][leetcode_454]

```python
def fourSumCount(A, B, C, D):
    """
    :type A: List[int]
    :type B: List[int]
    :type C: List[int]
    :type D: List[int]
    :rtype: int
    """
    sumABDict = {}
    for a in A:
        for b in B:
            sumAB = a + b
            if sumAB not in sumABDict:
                sumABDict[sumAB] = 0
            sumABDict[sumAB] += 1
    result = 0
    for c in C:
        for d in D:
            sumCD = -c - d
            if sumCD in sumABDict:
                result += sumABDict[sumCD]
    return result
```

### 12.35. 计算给出的多个时间中，最小的时间差

[Leetcode 539. Minimum Time Difference][leetcode_539]

```java
public int findMinDifference(List<String> timePoints) {
    boolean[] mark = new boolean[24 * 60];
    for (String time : timePoints) {
        String[] t = time.split(":");
        int h = Integer.parseInt(t[0]);
        int m = Integer.parseInt(t[1]);
        if (mark[h * 60 + m]) return 0;
        mark[h * 60 + m] = true;
    }
    int prev = 0, min = Integer.MAX_VALUE;
    int first = Integer.MAX_VALUE, last = Integer.MIN_VALUE;
    for (int i = 0; i < 24 * 60; i++) {
        if (mark[i]) {
            if (first != Integer.MAX_VALUE) {
                min = Math.min(min, i - prev);
            }
            first = Math.min(first, i);
            last = Math.max(last, i);
            prev = i;
        }
    }
    min = Math.min(min, (24 * 60 - last + first));
    return min;
}
```

### 12.36. 计算\[0, 10^n)中各位数字不同的数的个数

[Leetcode 357. Count Numbers with Unique Digits][leetcode_357]

```python
def countNumbersWithUniqueDigits(n):
    """
    :type n: int
    :rtype: int
    """
    if n == 0:
        return 1
    map = [None] * (n + 1)
    map[1] = 10
    for i in range(2, n + 1):
        count = 9
        for j in range(9 - i + 2, 10):
            count *= j
        map[i] = map[i - 1] + count
    return map[n]
```

### 12.37. 数组中仅有两个数仅出现一次，其余的数均出现两次，找出这两个数

[Leetcode 260. Single Number III][leetcode_260]

```python
def singleNumber(nums):
    """
    :type nums: List[int]
    :rtype: List[int]
    """
    mixed_xor = 0
    for num in nums:
        mixed_xor ^= num
    diff = mixed_xor & (mixed_xor - 1) ^ mixed_xor
    first = 0
    second = 0
    for num in nums:
        if diff & num:
            first ^= num
        else:
            second ^= num
    return [first, second]
```

### 12.38. 找出递增数列中第n位的数字

[Leetcode 400. Nth Digit][leetcode_400]

```python
def findNthDigit(n):
    """
    :type n: int
    :rtype: int
    """
    digits = 1
    start = 1
    length = 9
    while (n > digits * length):
        n -= digits * length
        digits += 1
        start *= 10
        length *= 10
    n -= 1
    number = start + n // digits
    return int(str(number)[n % digits])
```

### 12.39. 计算小于n的质数的个数

[Leetcode 204. Count Primes][leetcode_204]

```python
def countPrimes(n):
    """
    :type n: int
    :rtype: int
    """
    if n < 2:
        return 0
    primes = [True] * n
    primes[0] = False
    primes[1] = False
    for i in range(2, int(n ** 0.5) + 1):
        if primes[i]:
            for j in range(i * i, n, i):
                primes[j] = False
    return sum(primes)
```

### 12.40. 由部分（可重复）给定数组元素相加得到指定值的情况数

[Leetcode 377. Combination Sum IV][leetcode_377]

```java
public int combinationSum4(int[] nums, int target) {
    int[] results = new int[target + 1];
    results[0] = 1;
    for (int i = 1; i <= target; i++) {
        for (int num : nums) {
            if (i - num >= 0) {
                results[i] += results[i - num];
            }
        }
    }
    return results[target];
}
```

### 12.41. 在有序矩阵中寻找第k大的数

[Leetcode 378. Kth Smallest Element in a Sorted Matrix][leetcode_378]

```java
public int kthSmallest(int[][] matrix, int k) {
    class Item {
        int value;
        int i;
        int j;

        public Item(int value, int i, int j) {
            this.value = value;
            this.i = i;
            this.j = j;
        }
    }
    int m = matrix.length;
    int n = matrix[0].length;
    PriorityQueue<Item> minHeap = new PriorityQueue<>(new Comparator<Item>() {
        @Override
        public int compare(Item o1, Item o2) {
            return o1.value - o2.value;
        }
    });
    for (int j = 0; j < n; j++) {
        minHeap.add(new Item(matrix[0][j], 0, j));
    }
    while (!minHeap.isEmpty()) {
        Item item = minHeap.poll();
        if (item.i < m - 1) {
            minHeap.add(new Item(matrix[item.i + 1][item.j], item.i + 1, item.j));
        }
        k--;
        if (k == 0) {
            return item.value;
        }
    }
    return 0;
}
```

### 12.42. 求n对括号的所有排列情况

[Leetcode 22. Generate Parentheses][leetcode_22]

```python
def generateParenthesis(n):
    """
    :type n: int
    :rtype: List[str]
    """

    def parenthesis(result, current, left, right):
        if left == 0 and right == 0:
            result.append(current)
        elif left >= 0 and right >= left:
            parenthesis(result, current + '(', left - 1, right)
            parenthesis(result, current + ')', left, right - 1)

    result = []
    parenthesis(result, '', n, n)
    return result
```

### 12.43. 给定字符串数组，求最大不相交的两个字符串的长度积

[Leetcode 318. Maximum Product of Word Lengths][leetcode_318]

```java
public int maxProduct(String[] words) {
    int[] bits = new int[words.length];
    int result = 0;
    for (int i = 0; i < words.length; i++) {
        int bit = 0;
        for (char letter : words[i].toCharArray()) {
            bit |= 1 << (letter - 'a');
        }
        bits[i] = bit;
    }
    for (int i = 0; i < bits.length; i++) {
        for (int j = i + 1; j < bits.length; j++) {
            if ((bits[i] & bits[j]) == 0 && words[i].length() * words[j].length() > result) {
                result = words[i].length() * words[j].length();
            }
        }
    }
    return result;
}
```

### 12.44. 在由[1, n]组成的长为n + 1的数组中，寻找重复的那个数

[Leetcode 287. Find the Duplicate Number][leetcode_287]

```java
public int findDuplicate(int[] nums) {
    int low = 1;
    int high = nums.length - 1;
    while (low < high) {
        int mid = (low + high) / 2;
        int count = 0;
        for (int num : nums) {
            if (num <= mid) {
                count++;
            }
        }
        if (count <= mid) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    return low;
}
```

### 12.45. 求给定数组的所有排列情况

[Leetcode 46. Permutations][leetcode_46]

```java
public List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    result.add(new ArrayList<>());
    for (int i = 0; i < nums.length; i++) {
        List<List<Integer>> newResult = new ArrayList<>();
        for (int j = 0; j <= i; j++) {
            for (List<Integer> item : result) {
                List<Integer> newItem = new ArrayList<>(item);
                newItem.add(j, nums[i]);
                newResult.add(newItem);
            }
        }
        result = newResult;
    }
    return result;
}
```

### 12.46. 求给定（元素可重复）数组的所有排列情况

[Leetcode 47. Permutations II][leetcode_47]

```python
def permuteUnique(self, nums):
    """
    :type nums: List[int]
    :rtype: List[List[int]]
    """
    result = []
    result.append([])
    for i, num in enumerate(nums):
        current_result = []
        for item in result:
            for j in range(i + 1):
                if j > 0 and num == item[j - 1]:
                    break
                temp = item[:]
                temp.insert(j, num)
                current_result.append(temp)
        result = current_result
    return result
```

### 12.47. 最长回文子序列

[Leetcode 516. Longest Palindromic Subsequence][leetcode_516]

```java
public int longestPalindromeSubseq(String s) {
    int[][] dp = new int[s.length()][s.length()];
    for (int i = s.length() - 1; i >= 0; i--) {
        dp[i][i] = 1;
        for (int j = i + 1; j < s.length(); j++) {
            if (s.charAt(i) == s.charAt(j)) {
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[0][s.length() - 1];
}
```

### 12.48. 将[1, n]的数按字典排序

[Leetcode 386. Lexicographical Numbers][leetcode_386]

```python
def lexicalOrder(n):
    """
    :type n: int
    :rtype: List[int]
    """

    def dfs(result, current, n):
        if current > n:
            return
        result.append(current)
        current *= 10
        if current <= n:
            for i in range(10):
                if current + i <= n:
                    dfs(result, current + i, n)

    result = []
    for i in range(1, 10):
        dfs(result, i, n)
    return result
```

### 12.49. 二叉搜索树迭代器

[Leetcode 173. Binary Search Tree Iterator][leetcode_173]

```python
class BSTIterator(object):
    def __init__(self, root):
        """
        :type root: TreeNode
        """
        self.stack = []
        while root:
            self.stack.append(root)
            root = root.left

    def hasNext(self):
        """
        :rtype: bool
        """
        return self.stack

    def next(self):
        """
        :rtype: int
        """
        node = self.stack.pop()
        result = node.val
        node = node.right
        while node:
            self.stack.append(node)
            node = node.left
        return result
```

### 12.50. 由[1, n]组成的二叉搜索树的个数

[Leetcode 96. Unique Binary Search Trees][leetcode_96]

```java
public int numTrees(int n) {
    int[] results = new int[n + 1];
    results[0] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < i; j++) {
            results[i] += results[j] * results[i - j - 1];
        }
    }
    return results[n];
}
```

### 12.51. 格雷码

[Leetcode 89. Gray Code][leetcode_89]

```python
def grayCode(n):
    """
    :type n: int
    :rtype: List[int]
    """
    return [i ^ (i >> 1) for i in range(1 << n)]
```

### 12.52. 从m x n棋盘左上角走到右下角的路径总数

[Leetcode 62. Unique Paths][leetcode_62]

```java
public int uniquePaths(int m, int n) {
    int[][] dp = new int[m][n];
    for (int i = 0; i < m; i++) {
        dp[i][0] = 1;
    }
    for (int j = 0; j < n; j++) {
        dp[0][j] = 1;
    }
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}
```

### 12.54. 求集合的所有子集

[Leetcode 78. Subsets][leetcode_78]

```python
def subsets(nums):
    """
    :type nums: List[int]
    :rtype: List[List[int]]
    """
    result = []
    for i in range(1 << len(nums)):
        current = []
        for j in range(len(nums)):
            if i & 1 << j:
                current.append(nums[j])
        result.append(current)
    return result
```

### 12.55. 求（元素可重复）集合的所有子集

[Leetcode 90. Subsets II][leetcode_90]

```python
def subsetsWithDup(self, nums):
    """
    :type nums: List[int]
    :rtype: List[List[int]]
    """
    result = [[]]
    nums.sort()
    last_start = 0
    for i, num in enumerate(nums):
        start = last_start if (i > 0 and nums[i] == nums[i - 1]) else 0
        last_start = len(result)
        for item in result[start:last_start]:
            temp = item[:]
            temp.append(num)
            result.append(temp)
    return result
```

### 12.56. 判断数组arr中是否存在arr[i] &lt; arr[j] &lt; arr[k]

[Leetcode 334. Increasing Triplet Subsequence][leetcode_334]

```java
public boolean increasingTriplet(int[] nums) {
    int first = Integer.MAX_VALUE;
    int second = Integer.MAX_VALUE;
    for (int num : nums) {
        if (num < first) {
            first = num;
        } else if (num < second && num > first) {
            second = num;
        } else if (num > second) {
            return true;
        }
    }
    return false;
}
```

### 12.57. 查找数组中第k大的数

[Leetcode 215. Kth Largest Element in an Array][leetcode_215]

```python
def find_kth_largest(nums, k):
    def partition(array, low, high):
        pivot = array[low]
        while low < high:
            while low < high and array[high] >= pivot:
                high -= 1
            array[low] = array[high]
            while low < high and array[low] <= pivot:
                low += 1
            array[high] = array[low]
        array[low] = pivot
        return low

    random.shuffle(nums)
    k = len(nums) - k
    low = 0
    high = len(nums) - 1
    while low < high:
        index = partition(nums, low, high)
        if index < k:
            low = index + 1
        elif index > k:
            high = index - 1
        else:
            break
    return nums[k]
```

### 12.58. 链表删除倒数第n个结点

[Leetcode 19. Remove Nth Node From End of List][leetcode_19]

```python
def removeNthFromEnd(head, n):
    """
    :type head: ListNode
    :type n: int
    :rtype: ListNode
    """
    first = head
    second = head
    prev = head
    while n:
        first = first.next
        n -= 1
    while first:
        first = first.next
        prev = second
        second = second.next
    if second == head:
        return head.next
    prev.next = prev.next.next
    return head
```

### 12.59. 判断数组是否可以拼接为正方形

[Leetcode 473. Matchsticks to Square][leetcode_473]

```java
public boolean makesquare(int[] nums) {
    class Utils {
        boolean square(int[] nums, int[] edges, int start) {
            if (start == nums.length) {
                return edges[0] == 0 && edges[1] == 0 && edges[2] == 0 && edges[3] == 0;
            }
            int current = nums[start];
            for (int i = 0; i < edges.length; i++) {
                if (edges[i] >= current) {
                    edges[i] -= current;
                    if (square(nums, edges, start + 1)) {
                        return true;
                    }
                    edges[i] += current;
                }
            }
            return false;
        }
    }
    if (nums.length < 4) {
        return false;
    }
    int sumNums = 0;
    for (int num : nums) {
        sumNums += num;
    }
    if (sumNums % 4 != 0) {
        return false;
    }
    int[] edges = new int[4];
    Arrays.fill(edges, sumNums / 4);
    Arrays.sort(nums);
    for (int left = 0, right = nums.length - 1; left < right; left++, right--) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
    Utils utils = new Utils();
    return utils.square(nums, edges, 0);
}
```

### 12.60. 快速`pow()`

[Leetcode 372. Super Pow][leetcode_372]

```java
public int normalPow(int a, int b) {
    int result = 1;
    while (b != 0) {
        if (b % 2 != 0)
            result = result * a % M;
        a = a * a % M;
        b /= 2;
    }
    return result;
}

public int superPow(int a, int[] b) {
    a %= M;
    int result = 1;
    for (int i = b.length - 1; i >= 0; i--) {
        result = result * normalPow(a, b[i]) % M;
        a = normalPow(a, 10);
    }
    return result;
```

### 12.61. 判断数组是否可以分为相等的两部分

[Leetcode 416. Partition Equal Subset Sum][leetcode_416]

```java
public boolean canPartition(int[] nums) {
    int target = 0;
    for (int num : nums) {
        target += num;
    }
    if (target % 2 == 1) {
        return false;
    }
    target /= 2;
    boolean[][] dp = new boolean[nums.length + 1][target + 1];
    dp[0][0] = true;
    for (int i = 1; i <= nums.length; i++) {
        for (int j = 0; j <= target; j++) {
            dp[i][j] = dp[i - 1][j];
            if (j >= nums[i - 1]) {
                dp[i][j] = dp[i][j] || dp[i - 1][j - nums[i - 1]];
            }
        }
    }
    return dp[nums.length][target];
}
```

### 12.62. 在矩阵中查找指定值

[Leetcode 240. Search a 2D Matrix II][leetcode_240]

```python
def searchMatrix(matrix, target):
    """
    :type matrix: List[List[int]]
    :type target: int
    :rtype: bool
    """
    if not matrix:
        return False
    i = 0
    j = len(matrix[0]) - 1
    while i < len(matrix) and j >= 0:
        current = matrix[i][j]
        if current == target:
            return True
        elif current > target:
            j -= 1
        else:
            i += 1
    return False
```

### 12.63. 将矩阵顺时针旋转90度

[Leetcode 48. Rotate Image][leetcode_48]

```python
def rotate(matrix):
    """
    :type matrix: List[List[int]]
    :rtype: void Do not return anything, modify matrix in-place instead.
    """
    m = len(matrix)
    n = len(matrix[0])
    for i in range(m // 2):
        matrix[i], matrix[m - i - 1] = matrix[m - i - 1], matrix[i]
    for i in range(m):
        for j in range(i + 1, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
```

### 12.64. 最长递增子序列

[Leetcode 300. Longest Increasing Subsequence][leetcode_300]

```python
def lengthOfLIS(nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)
```

### 12.65. 求二维矩阵由左上角到右下角的最小和

[Leetcode 64. Minimum Path Sum][leetcode_64]

```java
public int minPathSum(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    int[][] dp = new int[m][n];
    dp[0][0] = grid[0][0];
    for (int i = 1; i < m; i++) {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
    }
    for (int j = 1; j < n; j++) {
        dp[0][j] = dp[0][j - 1] + grid[0][j];
    }
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
        }
    }
    return dp[m - 1][n - 1];
}
```

### 12.66. 将由0、1、2组成的数组排序

[Leetcode 75. Sort Colors][leetcode_75]

```python
def sortColors(self, nums):
    """
    :type nums: List[int]
    :rtype: void Do not return anything, modify nums in-place instead.
    """
    left = 0
    right = len(nums) - 1
    middle = 0
    while middle <= right:
        while nums[middle] == 2 and middle < right:
            nums[middle], nums[right] = nums[right], nums[middle]
            right -= 1
        while nums[middle] == 0 and middle > left:
            nums[middle], nums[left] = nums[left], nums[middle]
            left += 1
        middle += 1
```

### 12.67. 求第n位仅由指定因数组成的数字

[Leetcode 313. Super Ugly Number][leetcode_313]

```java
public int nthSuperUglyNumber(int n, int[] primes) {
    int[] factors = new int[primes.length];
    Arrays.fill(factors, 1);
    int[] indexes = new int[primes.length];
    Arrays.fill(indexes, -1);
    int[] ugly = new int[n];
    for (int i = 0; i < n; i++) {
        int theMin = Integer.MAX_VALUE;
        for (int factor : factors) {
            theMin = Math.min(theMin, factor);
        }
        ugly[i] = theMin;
        for (int j = 0; j < factors.length; j++) {
            if (ugly[i] == factors[j]) {
                indexes[j]++;
                factors[j] = ugly[indexes[j]] * primes[j];
            }
        }
    }
    return ugly[ugly.length - 1];
}
```

### 12.68. 数组中查找极大值

[Leetcode 162. Find Peak Elementr][leetcode_162]

```java
public int findPeakElement(int[] nums) {
    if (nums.length == 1 || nums[0] > nums[1]) {
        return 0;
    }
    if (nums[nums.length - 2] < nums[nums.length - 1]) {
        return nums.length - 1;
    }
    int low = 0;
    int high = nums.length - 1;
    while (low < high) {
        int mid = (low + high) / 2;
        if (nums[mid] < nums[mid + 1]) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    return low;
}
```

### 12.69. 判断n能否由平方数的和组成

[Leetcode 279. Perfect Squares][leetcode_279]

```python
def numSquares(self, n):
    """
    :type n: int
    :rtype: int
    """
    dp = [n] * (n + 1)
    dp[0] = 0
    for i in range(1, n + 1):
        j = 1
        while j * j <= i:
            dp[i] = min(dp[i], dp[i - j * j] + 1)
            j += 1
    return dp[n]
```

### 12.70. 删除二叉搜索树中的结点

[Leetcode 450. Delete Node in a BST][leetcode_450]

```python
def deleteNode(root, key):
    """
    :type root: TreeNode
    :type key: int
    :rtype: TreeNode
    """
    if not root:
        return None
    if root.val > key:
        root.left = deleteNode(root.left, key)
    elif root.val < key:
        root.right = deleteNode(root.right, key)
    else:
        if not root.left:
            return root.right
        elif not root.right:
            return root.left
        else:
            replace = root.right
            while replace.left:
                replace = replace.left
            root.val = replace.val
            root.right = deleteNode(root.right, root.val)
    return root
```

### 12.71. 检查字符串是否是合法的二叉树前序遍历结果

[Leetcode 331. Verify Preorder Serialization of a Binary Tree][leetcode_331]

```python
def isValidSerialization(self, preorder):
    """
    :type preorder: str
    :rtype: bool
    """
    degree = -1
    for node in preorder.split(','):
        degree += 1
        if degree > 0:
            return False
        if node != '#':
            degree -= 2
    return degree == 0
```

### 12.72. 中缀表达式转后缀表达式

```java
String infixToPostfix(String infix) {
    Map<Character, Integer> priority = new HashMap<>();
    priority.put('(', 1);
    priority.put(')', -1);
    priority.put('+', 2);
    priority.put('-', 2);
    priority.put('*', 3);
    priority.put('/', 3);
    priority.put('^', 3);
    StringBuilder builder = new StringBuilder();
    Stack<Character> stack = new Stack<>();
    for (char c : infix.toCharArray()) {
        if (priority.containsKey(c)) {
            if (c == '(') {
                stack.push(c);
            } else if (c == ')') {
                while (!stack.empty() && stack.peek() != '(') {
                    builder.append(stack.pop());
                }
                if (!stack.empty()) {
                    stack.pop();
                }
            } else {
                while (!stack.empty() && priority.get(stack.peek()) >= priority.get(c)) {
                    builder.append(stack.pop());
                }
                stack.push(c);
            }
        } else {
            builder.append(c);
        }
    }
    while (!stack.empty()) {
        builder.append(stack.pop());
    }
    return builder.toString();
}
```

### 12.73. 排列的下一种情况

[Leetcode 31. Next Permutation][leetcode_31]

```python
def nextPermutation(self, nums):
    """
    :type nums: List[int]
    :rtype: void Do not return anything, modify nums in-place instead.
    """
    i = len(nums) - 2
    while i >= 0 and nums[i] >= nums[i + 1]:
        i -= 1
    if i < 0:
        nums.sort()
        return
    j = len(nums) - 1
    while nums[j] <= nums[i]:
        j -= 1
    nums[i], nums[j] = nums[j], nums[i]
    nums[i + 1:] = sorted(nums[i + 1:])
```

### 12.74. 求旋转有序数组的最小值

[Leetcode 153. Find Minimum in Rotated Sorted Array][leetcode_153]

```python
def findMin(self, nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    length = len(nums)
    low = 0
    high = length - 1
    while low < high:
        mid = (low + high) // 2
        if nums[mid] > nums[high]:
            low = mid + 1
        else:
            high = mid
    return nums[low]
```

### 12.75. 在旋转有序数组中查找指定值

[Leetcode 33. Search in Rotated Sorted Array][leetcode_33]

```python
def search(self, nums, target):
    """
    :type nums: List[int]
    :type target: int
    :rtype: int
    """
    length = len(nums)
    low = 0
    high = length - 1
    while low < high:
        mid = (low + high) // 2
        if nums[mid] > nums[high]:
            low = mid + 1
        else:
            high = mid
    rotate = low
    low = 0
    high = length - 1
    while low <= high:
        mid = (low + high) // 2
        real_mid = (mid + rotate) % length
        if nums[real_mid] == target:
            return real_mid
        if nums[real_mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1
```

### 12.76. 在旋转（元素可重复）有序数组中查找指定值

[Leetcode 81. Search in Rotated Sorted Array II][leetcode_81]

```python
def search(self, nums, target):
    """
    :type nums: List[int]
    :type target: int
    :rtype: bool
    """
    if not nums:
        return False
    low = 0
    high = len(nums) - 1
    while low < high:
        mid = (low + high) // 2
        if nums[mid] == target:
            return True
        if nums[mid] > nums[high]:
            if nums[low] <= target < nums[mid]:
                high = mid
            else:
                low = mid + 1
        elif nums[mid] < nums[high]:
            if nums[mid] < target <= nums[high]:
                low = mid + 1
            else:
                high = mid
        else:
            high -= 1
    return nums[low] == target
```

### 12.77. 有序数组中查找特定元素的第一个和最后一个索引

[Leetcode 34. Search for a Range][leetcode_34]

```python
def searchRange(self, nums, target):
    """
    :type nums: List[int]
    :type target: int
    :rtype: List[int]
    """

    def search(nums, target):
        low = 0
        high = len(nums) - 1
        while low <= high:
            mid = (low + high) // 2
            if nums[mid] < target:
                low = mid + 1
            else:
                high = mid - 1
        return low

    if not nums:
        return [-1, -1]
    low = search(nums, target)
    if low == len(nums) or nums[low] != target:
        return [-1, -1]
    high = search(nums, target + 1)
    high -= 1
    return [low, high]
```

### 12.78. 有序数组中查找指定值的插入位置

[Leetcode 35. Search Insert Position][leetcode_35]

```python
def searchInsert(self, nums, target):
    """
    :type nums: List[int]
    :type target: int
    :rtype: int
    """
    low = 0
    high = len(nums) - 1
    while low < high:
        mid = (low + high) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] > target:
            high = mid - 1
        else:
            low = mid + 1
    return low
```

### 12.79. 实现`pow(x, n)`

[Leetcode 50. Pow(x, n)][leetcode_50]

```python
def myPow(self, x, n):
    """
    :type x: float
    :type n: int
    :rtype: float
    """
    if not n:
        return 1
    if n < 0:
        n = -n
        x = 1 / x
    if n % 2:
        return x * myPow(x * x, n // 2)
    return myPow(x * x, n // 2)
```

### 12.80. 第k个排列

[Leetcode 60. Permutation Sequence][leetcode_60]

```python
def getPermutation(self, n, k):
    """
    :type n: int
    :type k: int
    :rtype: str
    """
    factor = [0] * n
    factor[0] = 1
    for i in range(1, n):
        factor[i] = factor[i - 1] * i
    result = ''
    k -= 1
    numbers = [i for i in range(1, 10)]
    for i in range(n - 1, -1, -1):
        number = k // factor[i]
        k %= factor[i]
        result += str(numbers[number])
        del numbers[number]
    return result
```

### 12.81. 链表向右循环移动k个位置

[Leetcode 61. Rotate List][leetcode_61]

```python
def rotateRight(self, head, k):
    """
    :type head: ListNode
    :type k: int
    :rtype: ListNode
    """
    if not head:
        return head
    tail = head
    length = 1
    while tail.next:
        tail = tail.next
        length += 1
    if k % length:
        tail.next = head
        step = length - k%length - 1
        new_head = head
        for i in range(step):
            new_head = new_head.next
        head = new_head.next
        new_head.next = None
    return head
```

### 12.82. 先序遍历和中序遍历构建二叉树

[Leetcode 105. Construct Binary Tree from Preorder and Inorder Traversal][leetcode_105]

```python
def buildTree(self, preorder, inorder):
    """
    :type preorder: List[int]
    :type inorder: List[int]
    :rtype: TreeNode
    """
    if not preorder or not inorder:
        return None
    node = TreeNode(preorder.pop(0))
    index = inorder.index(node.val)
    node.left = buildTree(preorder, inorder[:index])
    node.right = buildTree(preorder, inorder[index + 1:])
    return node
```

### 12.83. 中序遍历和后序遍历构建二叉树

[Leetcode 106. Construct Binary Tree from Inorder and Postorder Traversal][leetcode_106]

```python
def buildTree(self, inorder, postorder):
    """
    :type inorder: List[int]
    :type postorder: List[int]
    :rtype: TreeNode
    """
    if not inorder or not postorder:
        return None
    node = TreeNode(postorder.pop())
    index_inorder = inorder.index(node.val)
    node.right = buildTree(inorder[index_inorder + 1:], postorder)
    node.left = buildTree(inorder[:index_inorder], postorder)
    return node
```

### 12.84. 求杨辉三角第k行的值

[Leetcode 119. Pascal's Triangle II][leetcode_119]

```python
def getRow(self, rowIndex):
    """
    :type rowIndex: int
    :rtype: List[int]
    """
    result = [0] * (rowIndex + 1)
    result[0] = 1
    for row in range(1, rowIndex + 1):
        for i in range(row, 0, -1):
            result[i] += result[i - 1]
    return result
```

### 12.85. 克隆图

[Leetcode 119. Pascal's Triangle II][leetcode_119]

```python
def cloneGraph(self, node):
    def clone(node, memory):
        if node.label not in memory:
            copy = UndirectedGraphNode(node.label)
            memory[copy.label] = copy
            for neighbor in node.neighbors:
                copy.neighbors.append(clone(neighbor, memory))
        return memory[node.label]
    if not node:
        return node
    memory = {}
    return clone(node, memory)
```

### 12.86. 查找数组中的极大值元素

[Leetcode 162. Find Peak Element][leetcode_162]

```python
def findPeakElement(self, nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    if len(nums) == 1 or nums[0] > nums[1]:
        return 0
    if nums[-2] < nums[-1]:
        return len(nums) - 1
    low = 0
    high = len(nums) - 1
    while low < high:
        mid = (low + high) // 2
        if nums[mid] < nums[mid + 1]:
            low = mid + 1
        else:
            high = mid
    return low
```

### 12.87. 将数组合并拼接为最大的数

[Leetcode 179. Largest Number][leetcode_179]

```python
def largestNumber(self, nums):
    strs = [str(num) for num in nums]
    strs.sort(lambda x, y: 1 if x + y < y + x else -1 if x + y > y + x else 0)
    if strs[0] == '0':
        return '0'
    return ''.join(strs)
```

### 12.88. 计算完全二叉树的结点数

[Leetcode 222. Count Complete Tree Nodes][leetcode_222]

```python
def countNodes(self, root):
    """
    :type root: TreeNode
    :rtype: int
    """
    if not root:
        return 0
    depth_left = 0
    node_left = root
    while node_left:
        depth_left += 1
        node_left = node_left.left
    depth_right = 0
    node_right = root
    while node_right:
        depth_right += 1
        node_right = node_right.right
    if depth_left == depth_right:
        return 2 ** depth_left - 1
    return 1 + self.countNodes(root.left) + self.countNodes(root.right)
```

### 12.89. 加减乘除（无括号）计算器

[Leetcode 227. Basic Calculator II][leetcode_227]

```python
def calculate(self, s):
    """
    :type s: str
    :rtype: int
    """
    result = 0
    pre_number = 0
    pre_operator = '+'
    i = 0
    while i < len(s):
        while i < len(s) and s[i] == ' ':
            i += 1
        current = 0
        while i < len(s) and s[i] >= '0' and s[i] <= '9':
            current = current * 10 + ord(s[i]) - ord('0')
            i += 1
        if pre_operator == '+':
            result += pre_number
            pre_number = current
        elif pre_operator == '-':
            result += pre_number
            pre_number = -current
        elif pre_operator == '*':
            pre_number *= current
        else:
            temp = pre_number
            pre_number /= current
            if temp < 0 and temp % current:
                pre_number += 1
        while i < len(s) and s[i] == ' ':
            i += 1
        if i < len(s):
            pre_operator = s[i]
            i += 1
    result += pre_number
    return result
```

### 12.90. 加减（带括号）计算器

[Leetcode 224. Basic Calculator][leetcode_224]

```python
def calculate(self, s):
    """
    :type s: str
    :rtype: int
    """
    stack = []
    result = 0
    current = 0
    sign = 1
    for letter in s:
        if letter.isdigit():
            current = current * 10 + ord(letter) - ord('0')
        elif letter in ['+', '-']:
            result += sign * current
            current = 0
            sign = 1 if letter == '+' else -1
        elif letter == '(':
            stack.append(result)
            stack.append(sign)
            sign = 1
            result = 0
        elif letter == ')':
            result += sign * current
            result *= stack.pop()
            result += stack.pop()
            current = 0
    result += sign * current
    return result
```

### 12.91. 二叉搜索树中第k小的数

[Leetcode 230. Kth Smallest Element in a BST][leetcode_230]

```python
def kthSmallest(self, root, k):
    """
    :type root: TreeNode
    :type k: int
    :rtype: int
    """
    self.k = k
    self.result = None

    def smallest(root):
        if not root:
            return
        smallest(root.left)
        self.k -= 1
        if not self.k:
            self.result = root.val
            return
        smallest(root.right)

    smallest(root)
    return self.result
```

### 12.92. 求（元素可更新）数组指定区间的和

[Leetcode 307. Range Sum Query - Mutable][leetcode_307]

```python
class NumArray(object):
    class Node:
        def __init__(self, start, end):
            self.start = start
            self.end = end
            self.left = None
            self.right = None
            self.sum = 0

    def build(self, nums, start, end):
        if start > end:
            return None
        node = self.Node(start, end)
        if start == end:
            node.sum = nums[start]
        else:
            mid = (start + end) // 2
            node.left = self.build(nums, start, mid)
            node.right = self.build(nums, mid + 1, end)
            node.sum = node.left.sum + node.right.sum
        return node

    def __init__(self, nums):
        """
        :type nums: List[int]
        """
        self.root = self.build(nums, 0, len(nums) - 1)

    def update(self, i, val):
        """
        :type i: int
        :type val: int
        :rtype: void
        """

        def upd(node, i, val):
            if node.start == node.end:
                node.sum = val
            else:
                mid = (node.start + node.end) // 2
                if i <= mid:
                    upd(node.left, i, val)
                else:
                    upd(node.right, i, val)
                node.sum = node.left.sum + node.right.sum

        upd(self.root, i, val)

    def sumRange(self, i, j):
        """
        :type i: int
        :type j: int
        :rtype: int
        """

        def sum_ran(node, start, end):
            if node.start == start and node.end == end:
                return node.sum
            mid = (node.start + node.end) // 2
            if end <= mid:
                return sum_ran(node.left, start, end)
            if start > mid:
                return sum_ran(node.right, start, end)
            return sum_ran(node.left, start, mid) + sum_ran(node.right, mid + 1, end)

        return sum_ran(self.root, i, j)
```

### 12.93. 求数组中任意两个元素异或的最大值

[Leetcode 421. Maximum XOR of Two Numbers in an Array][leetcode_421]

```python
def findMaximumXOR(self, nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    result = 0
    mask = 0
    for i in range(31, -1, -1):
        mask |= 1 << i
        nums_set = set()
        for num in nums:
            nums_set.add(num & mask)
        current = result | (1 << i)
        for num in nums_set:
            if num ^ current in nums_set:
                result = current
                break
    return result
```

### 12.94. 二叉搜索树的序列化和反序列化

[Leetcode 449. Serialize and Deserialize BST][leetcode_449]

```python
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.

        :type root: TreeNode
        :rtype: str
        """
        result = ''
        stack = []
        while root or stack:
            if root:
                result += str(root.val) + ' '
                stack.append(root)
                root = root.left
            else:
                node = stack.pop()
                root = node.right
        return result

    def deserialize(self, data):
        """Decodes your encoded data to tree.

        :type data: str
        :rtype: TreeNode
        """
        data = [int(item) for item in data.split()]

        def construct(data, i, j):
            if i == j:
                return None
            node = TreeNode(data[i])
            split_index = i + 1
            while split_index < j and data[split_index] < data[i]:
                split_index += 1
            node.left = construct(data, i + 1, split_index)
            node.right = construct(data, split_index, j)
            return node

        return construct(data, 0, len(data))
```

### 12.95. 轮流取数判断先取者是否必胜

[Leetcode 486. Predict the Winner][leetcode_486]

```python
def PredictTheWinner(self, nums):
    """
    :type nums: List[int]
    :rtype: bool
    """
    dp = [[0] * len(nums) for i in range(len(nums))]
    for j in range(len(nums)):
        current_sum = 0
        for i in range(j, -1, -1):
            current_sum += nums[i]
            if i == j:
                dp[i][i] = nums[i]
            else:
                dp[i][j] = max(current_sum - dp[i][j - 1], current_sum - dp[i + 1][j])
    return 2 * dp[0][len(nums) - 1] >= sum(nums)
```

### 12.96. 一串数加上分别加上加号或减号使其结果等于指定值

[Leetcode 494. Target Sum][leetcode_494]

```python
def findTargetSumWays(self, nums, S):
    """
    :type nums: List[int]
    :type S: int
    :rtype: int
    """
    sum_nums = sum(nums)
    if S > sum_nums or S < -sum_nums:
        return 0
    map = [0] * (2 * sum_nums + 1)
    map[sum_nums] = 1
    for num in nums:
        new_map = [0] * (2 * sum_nums + 1)
        for i in range(2 * sum_nums + 1):
            if map[i]:
                new_map[i + num] += map[i]
                new_map[i - num] += map[i]
        map = new_map
    return map[sum_nums + S]
```

### 12.97. 有序数组中除一个数仅出现一次外，其他数均出现两次，求这个数

[Leetcode 540. Single Element in a Sorted Array][leetcode_540]

```python
def singleNonDuplicate(self, nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    low = 0
    high = len(nums) - 1
    while low < high:
        mid = (low + high) // 2
        if (mid % 2 == 0 and nums[mid] == nums[mid + 1]) or (mid % 2 != 0 and nums[mid] == nums[mid - 1]):
            low = mid + 1
        else:
            high = mid - 1
    return nums[low]
```

### 12.98. 最长任意元素差最大为1的子序列

[Leetcode 594. Longest Harmonious Subsequence][leetcode_594]

```python
def findLHS(self, nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    memory = {}
    for num in nums:
        if num not in memory:
            memory[num] = 0
        memory[num] += 1
    result = 0
    for key, value in memory.items():
        if key + 1 in memory:
            result = max(result, value + memory[key + 1])
    return result
```

### 12.99. 数组中寻找任意三个元素的最大积

[Leetcode 628. Maximum Product of Three Numbers][leetcode_628]

```python
def maximumProduct(self, nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    max_1 = -sys.maxsize
    max_2 = -sys.maxsize
    max_3 = -sys.maxsize
    min_1 = sys.maxsize
    min_2 = sys.maxsize
    for num in nums:
        if num > max_1:
            max_3 = max_2
            max_2 = max_1
            max_1 = num
        elif num > max_2:
            max_3 = max_2
            max_2 = num
        elif num > max_3:
            max_3 = num
        if num < min_1:
            min_2 = min_1
            min_1 = num
        elif num < min_2:
            min_2 = num
    return max(max_1 * max_2 * max_3, max_1 * min_1 * min_2)
```

### 12.100. 快速替换10亿条标题中的5万个敏感词

Aho-Corasick算法（AC自动机）：

- 构造一棵Trie树；
- 构造失败指针；
- 模式匹配。

参考：[AC自动机算法详解 - 极限定律 - C++博客][aho_corasick_algorithm]

### 12.101. 轮流取数的必胜策略

问题描述：有2N个自然数，甲乙两人轮流取。一人一次取一个，而且只能取头尾两个数中的一个，取过的数划去，直到2N个数取完，取得的数的总和大的人获胜。那么，先取的人是否有必胜策略？

解决方法：先取的人只要取了奇数位上的数，就把偶数位的数留给后取的人，而且只要坚持取奇数位上的数，就一直会把偶数位上的数留给后取的人。这样就会取走所有奇数位上的数。（这种方法同样可使先取的人把所有偶数位上的数取走）所以，先取的人只要一开始算出是所有偶数位上的数总和大，还是所有奇数位上的数总和大，就一定会胜。

### 12.102. 最大公约数（辗转相除法）

```python
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a
```

### 12.103. 最小公倍数

`(a * b)/gcd(a, b)`

[leetcode_461]: https://leetcode.com/problems/hamming-distance/#/description

[leetcode_136]: https://leetcode.com/problems/single-number/#/description

[leetcode_448]: https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/#/description

[leetcode_371]: https://leetcode.com/problems/sum-of-two-integers/#/description

[leetcode_226]: https://leetcode.com/problems/invert-binary-tree/#/description

[leetcode_283]: https://leetcode.com/problems/move-zeroes/#/description

[leetcode_453]: https://leetcode.com/problems/minimum-moves-to-equal-array-elements/#/description

[leetcode_169]: https://leetcode.com/problems/majority-element/#/description

[leetcode_504]: https://leetcode.com/problems/base-7/#/description

[leetcode_401]: https://leetcode.com/problems/binary-watch/#/description

[leetcode_108]: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/#/description

[leetcode_121]: https://leetcode.com/problems/best-time-to-buy-and-sell-stock/#/description

[leetcode_231]: https://leetcode.com/problems/power-of-two/#/description

[leetcode_342]: https://leetcode.com/problems/power-of-four/#/description

[leetcode_198]: https://leetcode.com/problems/house-robber/#/description

[leetcode_101]: https://leetcode.com/problems/symmetric-tree/#/description

[leetcode_110]: https://leetcode.com/problems/balanced-binary-tree/#/description

[leetcode_367]: https://leetcode.com/problems/valid-perfect-square/#/description

[leetcode_172]: https://leetcode.com/problems/factorial-trailing-zeroes/#/description

[leetcode_26]: https://leetcode.com/problems/remove-duplicates-from-sorted-array/#/description

[leetcode_141]: https://leetcode.com/problems/linked-list-cycle/#/description

[leetcode_9]: https://leetcode.com/problems/palindrome-number/#/description

[leetcode_112]: https://leetcode.com/problems/path-sum/#/description

[leetcode_438]: https://leetcode.com/problems/find-all-anagrams-in-a-string/#/description

[leetcode_205]: https://leetcode.com/problems/isomorphic-strings/#/description

[leetcode_507]: https://leetcode.com/problems/perfect-number/#/description

[leetcode_384]: https://leetcode.com/problems/shuffle-an-array/#/description

[leetcode_454]: https://leetcode.com/problems/4sum-ii/#/description

[leetcode_539]: https://leetcode.com/problems/minimum-time-difference/#/description

[leetcode_357]: https://leetcode.com/problems/count-numbers-with-unique-digits/#/description

[leetcode_260]: https://leetcode.com/problems/single-number-iii/#/description

[leetcode_400]: https://leetcode.com/problems/nth-digit/#/description

[leetcode_204]: https://leetcode.com/problems/count-primes/#/description

[leetcode_377]: https://leetcode.com/problems/combination-sum-iv/#/description

[leetcode_378]: https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/#/description

[leetcode_22]: https://leetcode.com/problems/generate-parentheses/#/description

[leetcode_318]: https://leetcode.com/problems/maximum-product-of-word-lengths/#/description

[leetcode_287]: https://leetcode.com/problems/find-the-duplicate-number/#/description

[leetcode_46]: https://leetcode.com/problems/permutations/#/description

[leetcode_516]: https://leetcode.com/problems/longest-palindromic-subsequence/#/description

[leetcode_386]: https://leetcode.com/problems/lexicographical-numbers/#/description

[leetcode_173]: https://leetcode.com/problems/binary-search-tree-iterator/#/description

[leetcode_96]: https://leetcode.com/problems/unique-binary-search-trees/#/description

[leetcode_89]: https://leetcode.com/problems/gray-code/#/description

[leetcode_62]: https://leetcode.com/problems/unique-paths/#/description

[leetcode_78]: https://leetcode.com/problems/subsets/#/description

[leetcode_334]: https://leetcode.com/problems/increasing-triplet-subsequence/#/description

[leetcode_215]: https://leetcode.com/problems/kth-largest-element-in-an-array/#/description

[leetcode_19]: https://leetcode.com/problems/remove-nth-node-from-end-of-list/#/description

[leetcode_473]: https://leetcode.com/problems/matchsticks-to-square/#/description

[leetcode_372]: https://leetcode.com/problems/super-pow/#/description

[leetcode_416]: https://leetcode.com/problems/partition-equal-subset-sum/#/description

[leetcode_240]: https://leetcode.com/problems/search-a-2d-matrix-ii/#/description

[leetcode_48]: https://leetcode.com/problems/rotate-image/#/description

[leetcode_300]: https://leetcode.com/problems/longest-increasing-subsequence/#/description

[leetcode_64]: https://leetcode.com/problems/minimum-path-sum/#/description

[leetcode_75]: https://leetcode.com/problems/sort-colors/#/description

[leetcode_313]: https://leetcode.com/problems/super-ugly-number/#/description

[leetcode_162]: https://leetcode.com/problems/find-peak-element/#/description

[leetcode_279]: https://leetcode.com/problems/perfect-squares/#/description

[leetcode_450]: https://leetcode.com/problems/delete-node-in-a-bst/#/description

[leetcode_331]: https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/#/description

[aho_corasick_algorithm]: http://www.cppblog.com/mythit/archive/2009/04/21/80633.html

[leetcode_235]: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/

[leetcode_236]: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/

[leetcode_31]: https://leetcode.com/problems/next-permutation/description/

[leetcode_33]: https://leetcode.com/problems/search-in-rotated-sorted-array/description/

[leetcode_34]: https://leetcode.com/problems/search-for-a-range/description/

[leetcode_35]: https://leetcode.com/problems/search-insert-position/description/

[leetcode_47]: https://leetcode.com/problems/permutations-ii/description/

[leetcode_50]: https://leetcode.com/problems/powx-n/description/

[leetcode_60]: https://leetcode.com/problems/permutation-sequence/description/

[leetcode_61]: https://leetcode.com/problems/rotate-list/description/

[leetcode_81]: https://leetcode.com/problems/search-in-rotated-sorted-array-ii/description/

[leetcode_90]: https://leetcode.com/problems/subsets-ii/description/

[leetcode_105]: https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/

[leetcode_106]: https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/

[leetcode_119]: https://leetcode.com/problems/pascals-triangle-ii/description/

[leetcode_142]: https://leetcode.com/problems/linked-list-cycle-ii/description/

[leetcode_152]: https://leetcode.com/submissions/detail/95525167/

[leetcode_153]: https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/

[leetcode_162]: https://leetcode.com/problems/find-peak-element/description/

[leetcode_179]: https://leetcode.com/problems/largest-number/description/

[leetcode_222]: https://leetcode.com/problems/count-complete-tree-nodes/description/

[leetcode_227]: https://leetcode.com/problems/basic-calculator-ii/description/

[leetcode_224]: https://leetcode.com/problems/basic-calculator/description/

[leetcode_230]: https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/

[leetcode_307]: https://leetcode.com/submissions/detail/97819470/

[leetcode_421]: https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/description/

[leetcode_449]: https://leetcode.com/problems/serialize-and-deserialize-bst/description/

[leetcode_486]: https://leetcode.com/problems/predict-the-winner/description/

[leetcode_494]: https://leetcode.com/problems/target-sum/description/

[leetcode_540]: https://leetcode.com/problems/single-element-in-a-sorted-array/description/

[leetcode_594]: https://leetcode.com/problems/longest-harmonious-subsequence/description/

[leetcode_628]: https://leetcode.com/problems/maximum-product-of-three-numbers/description/

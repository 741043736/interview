# 设计模式

<!-- TOC -->

- [1. 单例模式](#1-单例模式)
- [2. 快速排序`partition`过程](#2-快速排序partition过程)
  - [2.1. 方法一](#21-方法一)
  - [2.2. 方法二](#22-方法二)
  - [2.3. 方法三](#23-方法三)
- [3. 快速排序](#3-快速排序)
  - [3.1. 递归](#31-递归)
  - [3.2. 非递归](#32-非递归)
- [4. 插入排序](#4-插入排序)
- [5. 冒泡排序](#5-冒泡排序)
- [6. 选择排序](#6-选择排序)
- [7. 归并排序](#7-归并排序)
  - [7.1. 递归](#71-递归)
  - [7.2. 非递归](#72-非递归)
- [8. 堆排序](#8-堆排序)
- [9. 反转链表（头插法）](#9-反转链表头插法)
- [10. 单链表去重](#10-单链表去重)
- [11. 合并两个链表](#11-合并两个链表)
- [12. 检查回文链表](#12-检查回文链表)
- [13. 链表等概率随机抽取元素](#13-链表等概率随机抽取元素)
- [14. 链表按奇数序号和偶数序号重排](#14-链表按奇数序号和偶数序号重排)
- [15. 二叉树前序遍历](#15-二叉树前序遍历)
  - [15.1. 递归](#151-递归)
  - [15.2. 非递归](#152-非递归)
- [16. 二叉树中序遍历](#16-二叉树中序遍历)
  - [16.1. 递归](#161-递归)
  - [16.2. 非递归](#162-非递归)
- [17. 二叉树后序遍历](#17-二叉树后序遍历)
  - [17.1. 递归](#171-递归)
  - [17.2. 非递归](#172-非递归)
- [18. 二叉树层次遍历](#18-二叉树层次遍历)
- [19. Dijkstra算法](#19-dijkstra算法)
  - [19.1. 朴素](#191-朴素)
  - [19.2. 堆优化](#192-堆优化)
- [20. Floyd-Warshall算法](#20-floyd-warshall算法)
- [21. 拓扑排序](#21-拓扑排序)
  - [21.1. DFS](#211-dfs)
  - [21.2. BFS](#212-bfs)
- [22. 二分搜索](#22-二分搜索)
- [23. 并查集](#23-并查集)
- [24. Trie树](#24-trie树)
- [25. N皇后问题](#25-n皇后问题)
- [26. 栈模拟队列](#26-栈模拟队列)
- [27. 队列模拟栈](#27-队列模拟栈)
- [28. 生产者——消费者模型](#28-生产者消费者模型)
- [29. LRU](#29-lru)
- [30. LFU](#30-lfu)
- [31. 自顶向下](#31-自顶向下)
- [32. 自底向上](#32-自底向上)
- [33. 计算数字二进制表示的1的个数](#33-计算数字二进制表示的1的个数)
- [34. 数组中除一个数仅出现一次外，其他数均出现两次，找出这个数](#34-数组中除一个数仅出现一次外其他数均出现两次找出这个数)
- [35. 长为n的数组中所有元素在\[1, n\]之间，元素最多出现两次，找出\[1, n\]中没出现的元素](#35-长为n的数组中所有元素在1-n之间元素最多出现两次找出1-n中没出现的元素)
- [36. 不用`+`和`-`计算两个数的和](#36-不用和-计算两个数的和)
- [37. 反转二叉树](#37-反转二叉树)
- [38. 把数组中所有0移动到尾部，数组元素保持相对顺序不变](#38-把数组中所有0移动到尾部数组元素保持相对顺序不变)
- [39. 定义一次move是将长为n的数组中n-1个数均加1，最少多少个move可以使得数组中所有元素相等](#39-定义一次move是将长为n的数组中n-1个数均加1最少多少个move可以使得数组中所有元素相等)
- [40. 找出长为n的数组中出现次数大于⌊ n/2 ⌋的元素](#40-找出长为n的数组中出现次数大于⌊-n2-⌋的元素)
- [41. 找出长为n的数组中出现次数大于⌊ n/k ⌋的元素](#41-找出长为n的数组中出现次数大于⌊-nk-⌋的元素)
- [42. 十进制转换为7进制](#42-十进制转换为7进制)
- [43. 指定长度二进制数，指定1的个数的所有可能情况](#43-指定长度二进制数指定1的个数的所有可能情况)
- [44. 有序数组转二叉搜索树](#44-有序数组转二叉搜索树)
- [45. 最大子数列问题](#45-最大子数列问题)
  - [45.1. 最小值为0](#451-最小值为0)
  - [45.2. 最小值为负数](#452-最小值为负数)
- [46. 判断一个数是否为2的幂次](#46-判断一个数是否为2的幂次)
- [47. 判断一个数是否为4的幂次](#47-判断一个数是否为4的幂次)
- [48. 最近公共祖先问题](#48-最近公共祖先问题)
  - [48.1. 二叉树的最近公共祖先](#481-二叉树的最近公共祖先)
  - [48.2. 二叉搜索树的最近公共祖先](#482-二叉搜索树的最近公共祖先)
- [49. 挑选数组中不连续的元素，使其和最大](#49-挑选数组中不连续的元素使其和最大)
- [50. 镜像二叉树](#50-镜像二叉树)
- [51. 判断二叉树是否平衡](#51-判断二叉树是否平衡)
- [52. 二分法求平方根](#52-二分法求平方根)
- [53. n!求末尾0的个数](#53-n求末尾0的个数)
- [54. 有序数组去重](#54-有序数组去重)
- [55. 链表判断环](#55-链表判断环)
- [56. 判断是否为回文数](#56-判断是否为回文数)
- [57. 是否存在二叉树根到叶子节点路径和为指定值](#57-是否存在二叉树根到叶子节点路径和为指定值)
- [58. 找出字符串中所有变位词](#58-找出字符串中所有变位词)
- [59. 判断两个字符串是否为同构字符串](#59-判断两个字符串是否为同构字符串)
- [60. 判断一个数是否为其全部约数的和](#60-判断一个数是否为其全部约数的和)
- [61. 打乱数组元素](#61-打乱数组元素)
- [62. 生成不重复随机序列](#62-生成不重复随机序列)
- [63. 使用随机生成0到5的函数，实现随机生成0到7的函数](#63-使用随机生成0到5的函数实现随机生成0到7的函数)
- [64. 计算数组A、B、C、D中有多少种(i, j, k, l)使得A\[i\] + B\[j\] + C\[k\] + D\[l\] = 0](#64-计算数组abcd中有多少种i-j-k-l使得ai--bj--ck--dl--0)
- [65. 计算给出的多个时间中，最小的时间差](#65-计算给出的多个时间中最小的时间差)
- [66. 计算\[0, 10^n)中各位数字不同的数的个数](#66-计算\0-10^n中各位数字不同的数的个数)
- [67. 数组中仅有两个数仅出现一次，其余的数均出现两次，找出这两个数](#67-数组中仅有两个数仅出现一次其余的数均出现两次找出这两个数)
- [68. 找出递增数列中第n位的数字](#68-找出递增数列中第n位的数字)
- [69. 计算小于n的质数的个数](#69-计算小于n的质数的个数)
- [70. 由部分（可重复）给定数组元素相加得到指定值的情况数](#70-由部分可重复给定数组元素相加得到指定值的情况数)
- [71. 在有序矩阵中寻找第k大的数](#71-在有序矩阵中寻找第k大的数)
- [72. 求n对括号的所有排列情况](#72-求n对括号的所有排列情况)
- [73. 给定字符串数组，求最大不相交的两个字符串的长度积](#73-给定字符串数组求最大不相交的两个字符串的长度积)
- [74. 在由\[1, n\]组成的长为n + 1的数组中，寻找重复的那个数](#74-在由1-n组成的长为n--1的数组中寻找重复的那个数)
- [75. 求给定数组的所有排列情况](#75-求给定数组的所有排列情况)
- [76. 最长回文子序列](#76-最长回文子序列)
- [77. 将\[1, n\]的数按字典排序](#77-将1-n的数按字典排序)
- [78. 二叉搜索树迭代器](#78-二叉搜索树迭代器)
- [79. 由\[1, n\]组成的二叉搜索树的个数](#79-由1-n组成的二叉搜索树的个数)
- [80. 格雷码](#80-格雷码)
- [81. 从m x n棋盘左上角走到右下角的路径总数](#81-从m-x-n棋盘左上角走到右下角的路径总数)
- [82. 求循环移位的有序数组中的到最小值](#82-求循环移位的有序数组中的到最小值)
- [83. 求集合的所有子集](#83-求集合的所有子集)
- [84. 判断数组arr中是否存在arr\[i\] &lt; arr\[j\] &lt; arr\[k\]](#84-判断数组arr中是否存在arri-lt-arrj-lt-arrk)
- [85. 查找数组中第k大的数](#85-查找数组中第k大的数)
- [86. 链表删除倒数第n个结点](#86-链表删除倒数第n个结点)
- [87. 判断数组是否可以拼接为正方形](#87-判断数组是否可以拼接为正方形)
- [88. 快速`pow()`](#88-快速pow)
- [89. 判断数组是否可以分为相等的两部分](#89-判断数组是否可以分为相等的两部分)
- [90. 在矩阵中查找指定值](#90-在矩阵中查找指定值)
- [91. 将矩阵顺时针旋转90度](#91-将矩阵顺时针旋转90度)
- [92. 最长递增子序列](#92-最长递增子序列)
- [93. 求二维矩阵由左上角到右下角的最小和](#93-求二维矩阵由左上角到右下角的最小和)
- [94. 将由0、1、2组成的数组排序](#94-将由012组成的数组排序)
- [95. 求第n位仅由指定因数组成的数字](#95-求第n位仅由指定因数组成的数字)
- [96. 数组中查找极大值](#96-数组中查找极大值)
- [97. 判断n能否由平方数的和组成](#97-判断n能否由平方数的和组成)
- [98. 删除二叉搜索树中的结点](#98-删除二叉搜索树中的结点)
- [99. 检查字符串是否是合法的二叉树前序遍历结果](#99-检查字符串是否是合法的二叉树前序遍历结果)
- [100. 中缀表达式转后缀表达式](#100-中缀表达式转后缀表达式)
- [101. 快速替换10亿条标题中的5万个敏感词](#101-快速替换10亿条标题中的5万个敏感词)
- [102. 轮流取数的必胜策略](#102-轮流取数的必胜策略)
- [103. 最大公约数（辗转相除法）](#103-最大公约数辗转相除法)
- [104. 最小公倍数](#104-最小公倍数)

<!-- /TOC -->

## 1. 单例模式

```java
public class Singleton {
    private volatile static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

# 排序

## 2. 快速排序`partition`过程

### 2.1. 方法一

```python
def partition(array, low, high):
    pivot = array[low]
    while low < high:
        while low < high and array[high] >= pivot:
            high -= 1
        array[low] = array[high]
        while low < high and array[low] <= pivot:
            low += 1
        array[high] = array[low]
    array[low] = pivot
    return low
```

### 2.2. 方法二

```python
def partition2(array, low, high):
    def swap(array, i, j):
        array[i], array[j] = array[j], array[i]

    pivot = array[high]
    current = low
    for i in range(low, high):
        if array[i] < pivot:
            swap(array, i, current)
            current += 1
    swap(array, high, current)
    return current
```

### 2.3. 方法三

```python
def partition3(array, low, high):
    def swap(array, i, j):
        array[i], array[j] = array[j], array[i]

    start = low
    pivot = array[low]
    low += 1
    while low <= high:
        while low <= high and array[low] <= pivot:
            low += 1
        while low <= high and array[high] >= pivot:
            high -= 1
        if low < high:
            swap(array, low, high)
    swap(array, start, high)
    return high
```

## 3. 快速排序

### 3.1. 递归

```python
def quick_sort(array, low, high):
    if low >= high:
        return
    mid = partition(array, low, high)
    quick_sort(array, low, mid - 1)
    quick_sort(array, mid + 1, high)
```

### 3.2. 非递归

```python
def quick_sort(array, low, high):
    stack = []
    stack.append(low)
    stack.append(high)
    while stack:
        high = stack.pop()
        low = stack.pop()
        if low >= high:
            continue
        mid = partition(array, low, high)
        stack.append(low)
        stack.append(mid - 1)
        stack.append(mid + 1)
        stack.append(high)
```

## 4. 插入排序

```python
def insertion_sort(array):
    for i in range(1, len(array)):
        temp = array[i]
        j = i - 1
        while j >= 0 and temp < array[j]:
            array[j + 1] = array[j]
            j -= 1
        array[j + 1] = temp
```

## 5. 冒泡排序

```python
def bubble_sort(array):
    def swap(array, i, j):
        array[i], array[j] = array[j], array[i]

    for j in range(len(array) - 1, 0, -1):
        flag = True
        for i in range(0, j):
            if array[i] > array[i + 1]:
                swap(array, i, i + 1)
                flag = False
        if flag:
            break
```

## 6. 选择排序

```python
def selection_sort(array):
    def swap(array, i, j):
        array[i], array[j] = array[j], array[i]

    for i in range(0, len(array) - 1):
        min_index = i
        for j in range(i + 1, len(array)):
            if array[j] < array[min_index]:
                min_index = j
        swap(array, i, min_index)
```

## 7. 归并排序

### 7.1. 递归

```python
def merge(array, temp_array, low, mid, high):
    start1 = low
    end1 = mid
    start2 = mid
    end2 = high
    k = low
    while start1 < end1 and start2 < end2:
        if array[start1] < array[start2]:
            temp_array[k] = array[start1]
            start1 += 1
        else:
            temp_array[k] = array[start2]
            start2 += 1
        k += 1
    while start1 < end1:
        temp_array[k] = array[start1]
        start1 += 1
        k += 1
    while start2 < end2:
        temp_array[k] = array[start2]
        start2 += 1
        k += 1
    for k in range(low, high):
        array[k] = temp_array[k]


def merge_sort(array, temp_array, low, high):
    if low >= high:
        return
    mid = (low + high) // 2
    merge_sort(array, temp_array, low, mid)
    merge_sort(array, temp_array, mid + 1, high)
    merge(array, temp_array, low, mid, high)
```

### 7.2. 非递归

```python
def merge_sort(array):
    length = len(array)
    temp_array = [0] * length
    block = 1
    while block < length * 2:
        for start in range(0, length, 2 * block):
            low = start
            mid = (start + block) if (start + block) < length else length
            high = (start + 2 * block) if (start + 2 * block) < length else length
            start1 = low
            end1 = mid
            start2 = mid
            end2 = high
            k = low
            while start1 < end1 and start2 < end2:
                if array[start1] < array[start2]:
                    temp_array[k] = array[start1]
                    start1 += 1
                else:
                    temp_array[k] = array[start2]
                    start2 += 1
                k += 1
            while start1 < end1:
                temp_array[k] = array[start1]
                start1 += 1
                k += 1
            while start2 < end2:
                temp_array[k] = array[start2]
                start2 += 1
                k += 1
        array, temp_array = temp_array, array
        block *= 2
```

## 8. 堆排序

```python
def heap_sort(array):
    def swap(array, i, j):
        array[i], array[j] = array[j], array[i]

    def shift_down(start, end):
        root = start
        while True:
            child = 2 * root + 1
            if child > end:
                break
            if child + 1 <= end and array[child] < array[child + 1]:
                child += 1
            if array[root] < array[child]:
                swap(array, root, child)
                root = child
            else:
                break

    def build_heap(array):
        length = len(array)
        for start in range((length - 1) // 2, -1, -1):
            shift_down(start, length - 1)

    build_heap(array)
    for end in range(len(array) - 1, 0, -1):
        swap(array, 0, end)
        shift_down(0, end - 1)
```

# 链表

## 9. 反转链表（头插法）

```python
def reverse_list(head):
    if not head:
        return head
    new_head = head
    while head.next:
        current = head.next
        head.next = head.next.next
        current.next = new_head
        new_head = current
    return new_head
```

## 10. 单链表去重

```java
public ListNode deleteDuplicates(ListNode head) {
    ListNode p = head;
    while (p != null) {
        if (p.next != null && p.next.val == p.val) {
            p.next = p.next.next;
        } else {
            p = p.next;
        }
    }
    return head;
}
```

## 11. 合并两个链表

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    if (l1 == null) {
        return l2;
    }
    if (l2 == null) {
        return l1;
    }
    if (l1.val > l2.val) {
        ListNode temp = l1;
        l1 = l2;
        l2 = temp;
    }
    ListNode p = l1;
    while (p != null) {
        while (l2 != null && (p.next == null || l2.val < p.next.val)) {
            ListNode temp = l2;
            l2 = l2.next;
            temp.next = p.next;
            p.next = temp;
            p = p.next;
        }
        p = p.next;
    }
    return l1;
}
```

## 12. 检查回文链表

```python
def isPalindrome(head):
    """
    :type head: ListNode
    :rtype: bool
    """
    if not head or not head.next:
        return True
    slow = head
    fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    temp = None
    while slow:
        next = slow.next
        slow.next = temp
        temp = slow
        slow = next
    slow = temp
    while head and slow:
        if head.val != slow.val:
            return False
        head = head.next
        slow = slow.next
    return True
```

## 13. 链表等概率随机抽取元素

```java
public int getRandom(ListNode head) {
    ListNode node = head;
    int result = -1;
    int count = 1;
    Random random = new Random();
    while (node != null) {
        if (random.nextInt(count) == 0) {
            result = node.val;
        }
        count++;
        node = node.next;
    }
    return result;
}
```

## 14. 链表按奇数序号和偶数序号重排

```python
def oddEvenList(head):
    """
    :type head: ListNode
    :rtype: ListNode
    """
    if not head:
        return None
    odd = head
    even = head.next
    even_head = even
    while even and even.next:
        odd.next = odd.next.next
        even.next = even.next.next
        odd = odd.next
        even = even.next
    odd.next = even_head
    return head
```

# 二叉树遍历

## 15. 二叉树前序遍历

### 15.1. 递归

```python
def pre_order(root):
    if root:
        print(root.val)
        pre_order(root.left)
        pre_order(root.right)
```

### 15.2. 非递归

```python
def pre_order(root):
    stack = []
    while root or stack:
        if root:
            print(root.val)
            stack.append(root)
            root = root.left
        else:
            node = stack.pop()
            root = node.right
```

## 16. 二叉树中序遍历

### 16.1. 递归

```python
def in_order(root):
    if root:
        in_order(root.left)
        print(root.val)
        in_order(root.right)
```

### 16.2. 非递归

```python
def in_order(root):
    stack = []
    while root or stack:
        if root:
            stack.append(root)
            root = root.left
        else:
            node = stack.pop()
            print(node.val)
            root = node.right
```

## 17. 二叉树后序遍历

### 17.1. 递归

```python
def post_order(root):
    if root:
        post_order(root.left)
        post_order(root.right)
        print(root.val)
```

### 17.2. 非递归

```python
def post_order(root):
    stack = []
    result = []
    node = root
    while node or stack:
        if node:
            stack.append(node)
            result.append(node.val)
            node = node.right
        else:
            node = stack.pop()
            node = node.left
    result.reverse()
    return result
```

## 18. 二叉树层次遍历

```python
def level_order(root):
    if not root:
        return
    queue = collections.deque()
    queue.append(root)
    while queue:
        size = len(queue)
        for i in range(size):
            node = queue.popleft()
            print(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
```

# 图

## 19. Dijkstra算法

### 19.1. 朴素

```python
def dijkstra(start, end, graph, n):
    """
    :param start: int, [1,n]
    :param end: int, [1,n]
    :param graph: dict, {from: (to, distance), from: (to, distance)...}
    :param n: int
    :return: (int, list), minimum distance, path
    """
    d = [sys.maxsize] * (n + 1)
    previous = [None] * (n + 1)
    d[start] = 0
    candidates = set(i for i in range(1, n + 1))
    while candidates:
        min_d = sys.maxsize
        u = -1
        for candidate in candidates:
            if min_d > d[candidate]:
                min_d = d[candidate]
                u = candidate
        if u == end:
            return d[u], previous
        candidates.remove(u)
        for v, dist in graph[u]:
            if d[v] > d[u] + dist:
                d[v] = d[u] + dist
                previous[v] = u
```

### 19.2. 堆优化

```python
def dijkstra(start, end, graph, n):
    """
    :param start: int, [1,n]
    :param end: int, [1,n]
    :param graph: dict, {from: (to, distance), from: (to, distance)...}
    :param n: int
    :return: (int, list), minimum distance, path
    """
    d = [sys.maxsize] * (n + 1)
    previous = [None] * (n + 1)
    d[start] = 0
    candidates = set(i for i in range(1, n + 1))
    heap = []
    heapq.heappush(heap, (0, start))
    while candidates:
        distance, u = heapq.heappop()
        if u == end:
            return d[u], previous
        if u not in candidates:
            continue
        candidates.remove(u)
        for v, dist in graph[u]:
            if d[v] > d[u] + dist:
                d[v] = d[u] + dist
                heapq.heappush(heap, (d[v], v))
                previous[v] = u
```

## 20. Floyd-Warshall算法

```python
def floyd_warshall(graph, n):
    INF = 10000
    dist = [[INF] * n for _ in range(n)]
    path = [[-1] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if i == j:
                dist[i][j] = 0
            elif graph[i][j] < INF:
                dist[i][j] = graph[i][j]
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][j] > dist[i][k] + dist[k][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
                    path[i][j] = k
    return dist, path
```

## 21. 拓扑排序

### 21.1. DFS

```python
def topological_sort(graph, n):
    order = []
    visiting = [False] * n
    visited = [False] * n
    for i in range(n):
        if not visited[i]:
            if not dfs(graph, i, visiting, visited, order):
                raise ValueError('cycle')
    order.reverse()
    return order


def dfs(graph, index, visiting, visited, order):
    visiting[index] = True
    visited[index] = True
    for neighbor in graph[index]:
        if visiting[neighbor]:
            return False
        if not visited[neighbor]:
            if not dfs(graph, neighbor, visiting, visited, order):
                return False
    order.append(index)
    visiting[index] = False
    return True
```

### 21.2. BFS

```python
def topological_sort(graph, n):
    in_degrees = [0] * n
    for i in range(n):
        for index in graph[i]:
            in_degrees[index] += 1
    candidates = set()
    for i in range(n):
        if in_degrees[i] == 0:
            candidates.add(i)
    order = []
    while candidates:
        index = candidates.pop()
        order.append(index)
        for neighbor in graph[index]:
            in_degrees[neighbor] -= 1
            if in_degrees[neighbor] == 0:
                candidates.add(neighbor)
    if len(order) != n:
        raise ValueError('cycle')
    return order
```

# 查找

## 22. 二分搜索

```python
def binary_search(array, key):
    low = 0
    high = len(array) - 1
    while low <= high:
        mid = (low + high) // 2
        if array[mid] == key:
            return mid
        elif array[mid] > key:
            high = mid - 1
        else:
            low = mid + 1
    return -1
```

## 23. 并查集

```python
class UnionFind:
    def __init__(self, n):
        self.count = n
        self.parent = [i for i in range(n)]
        self.rank = [0] * n

    def find(self, num):
        if num != self.parent[num]:
            self.parent[num] = self.find(self.parent[num])
        return self.parent[num]

    def union(self, a, b):
        parent_a = self.find(a)
        parent_b = self.find(b)
        if parent_a == parent_b:
            return
        if self.rank[parent_a] > self.rank[parent_b]:
            self.parent[parent_b] = parent_a
        else:
            self.parent[parent_a] = parent_b
            if self.rank[parent_a] == self.rank[parent_b]:
                self.rank[parent_b] += 1
        self.count -= 1
```

## 24. Trie树

```java
public class Trie {
    TrieNode root;

    class TrieNode {
        boolean isWord = false;
        char val;
        TrieNode[] children = new TrieNode[26];
    }

    public Trie() {
        root = new TrieNode();
    }

    public void insert(String word) {
        TrieNode current = root;
        for (char letter : word.toCharArray()) {
            if (current.children[letter - 'a'] == null) {
                current.children[letter - 'a'] = new TrieNode();
                current.children[letter - 'a'].val = letter;
            }
            current = current.children[letter - 'a'];
        }
        current.isWord = true;
    }

    public boolean search(String word) {
        TrieNode current = root;
        for (char letter : word.toCharArray()) {
            if (current.children[letter - 'a'] == null) {
                return false;
            }
            current = current.children[letter - 'a'];
        }
        return current.isWord;
    }

    public boolean startsWith(String prefix) {
        TrieNode current = root;
        for (char letter : prefix.toCharArray()) {
            if (current.children[letter - 'a'] == null) {
                return false;
            }
            current = current.children[letter - 'a'];
        }
        return true;
    }
}
```

# 回溯

## 25. N皇后问题

```python
def n_queens(n):
    """
    :type n: int
    :rtype: List[List[str]]
    """
    board = [['.'] * n for _ in range(n)]
    result = []
    back_trace(board, 0, result)
    return result


def back_trace(board, row_index, result):
    if row_index == len(board):
        result.append(convert(board))
        return
    for j in range(len(board[row_index])):
        if is_valid(board, row_index, j):
            board[row_index][j] = 'Q'
            back_trace(board, row_index + 1, result)
            board[row_index][j] = '.'


def convert(board):
    return [''.join(row) for row in board]


def is_valid(board, i, j):
    for x in range(i):
        for y in range(len(board[i])):
            if board[x][y] == 'Q' and (y == j or i - x == j - y or i - x == y - j):
                return False
    return True
```

# 栈与队列

## 26. 栈模拟队列

```java
public class MyQueue {
    Stack<Integer> stackA;
    Stack<Integer> stackB;

    public MyQueue() {
        stackA = new Stack<>();
        stackB = new Stack<>();
    }

    public void push(int x) {
        stackA.add(x);
    }

    public int pop() {
        if (stackB.empty()) {
            while (!stackA.empty()) {
                stackB.add(stackA.pop());
            }
        }
        return stackB.pop();
    }

    public int peek() {
        if (stackB.empty()) {
            while (!stackA.empty()) {
                stackB.add(stackA.pop());
            }
        }
        return stackB.peek();
    }

    public boolean empty() {
        return stackA.empty() && stackB.empty();
    }
}
```

## 27. 队列模拟栈

```java
public class MyStack {
    Queue<Integer> queue;

    public MyStack() {
        queue = new LinkedList<>();
    }

    public void push(int x) {
        queue.add(x);
        for (int i = 0; i < queue.size() - 1; i++) {
            queue.add(queue.poll());
        }
    }

    public int pop() {
        return queue.poll();
    }

    public int top() {
        return queue.peek();
    }

    public boolean empty() {
        return queue.isEmpty();
    }
}
```

# 同步问题

## 28. 生产者——消费者模型

```java
public class Main {
    public static void main(String[] args) {
        Queue<Integer> queue = new LinkedList<>();
        int maxSize = 10;
        Thread producer1 = new Producer(queue, maxSize, "Producer 1");
        Thread producer2 = new Producer(queue, maxSize, "Producer 2");
        Thread consumer1 = new Consumer(queue, "Consumer 1");
        Thread consumer2 = new Consumer(queue, "Consumer 2");

        producer1.start();
        consumer1.start();
        producer2.start();
        consumer2.start();
    }

    static class Producer extends Thread {
        Queue<Integer> queue;
        int maxSize;
        Random random;

        public Producer(Queue<Integer> queue, int maxSize, String name) {
            super(name);
            this.queue = queue;
            this.maxSize = maxSize;
            random = new Random();
        }

        @Override
        public void run() {
            while (true) {
                try {
                    produce();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }

        void produce() throws InterruptedException {
            synchronized (queue) {
                while (queue.size() == maxSize) {
                    System.out.println("Queue is full, " + this.getName() + " is waiting");
                    queue.wait();
                }
                int item = random.nextInt();
                queue.add(item);
                System.out.println(this.getName() + " produced " + item + ", queue size is " + queue.size() + " now");
                queue.notifyAll();
                Thread.sleep(new Random().nextInt(1000));
            }
        }
    }

    static class Consumer extends Thread {
        Queue<Integer> queue;
        Random random;

        public Consumer(Queue<Integer> queue, String name) {
            super(name);
            this.queue = queue;
            random = new Random();
        }

        @Override
        public void run() {
            while (true) {
                try {
                    consume();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }

        void consume() throws InterruptedException {
            synchronized (queue) {
                while (queue.isEmpty()) {
                    System.out.println("Queue is empty, " + this.getName() + " is waiting");
                    queue.wait();
                }
                int item = queue.remove();
                System.out.println(this.getName() + " consumed " + item + ", queue size is " + queue.size() + " now");
                queue.notifyAll();
                Thread.sleep(new Random().nextInt(1000));
            }
        }
    }
}
```

# 缓存策略

## 29. LRU

```python
class LRUCache:
    class Node:
        def __init__(self, key, value):
            self.key = key
            self.val = value
            self.prev = None
            self.next = None

    def __init__(self, capacity):
        """
        :type capacity: int
        """
        self.capacity = capacity
        self.memory = {}
        self.head = self.Node(-1, -1)
        self.tail = self.Node(-1, -1)
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key):
        """
        :type key: int
        :rtype: int
        """
        if key not in self.memory:
            return -1
        node = self.memory[key]
        self.to_head(node)
        return node.val

    def put(self, key, value):
        """
        :type key: int
        :type value: int
        :rtype: void
        """
        if key in self.memory:
            node = self.memory[key]
            node.val = value
            self.to_head(node)
        else:
            if len(self.memory) == self.capacity:
                del self.memory[self.tail.prev.key]
                self.remove(self.tail.prev)
            node = self.Node(key, value)
            self.memory[key] = node
            self.add(node)

    def to_head(self, node):
        self.remove(node)
        self.add(node)

    def remove(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

    def add(self, node):
        node.next = self.head.next
        self.head.next = node
        node.prev = self.head
        node.next.prev = node
```

## 30. LFU

```python
class LFUCache:
    class Node:
        def __init__(self, key, value, times):
            self.key = key
            self.value = value
            self.times = times
            self.prev = None
            self.next = None

    def __init__(self, capacity):
        """
        :type capacity: int
        """
        self.init_capacity = capacity
        self.capacity = capacity
        self.memory_nodes = {}
        self.memory_times = {}
        self.head = self.Node(-1, -1, -1)
        self.tail = self.Node(-1, -1, -1)
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key):
        """
        :type key: int
        :rtype: int
        """
        if key not in self.memory_nodes:
            return -1
        self.put(key, self.memory_nodes[key].value)
        return self.memory_nodes[key].value

    def put(self, key, value):
        """
        :type key: int
        :type value: int
        :rtype: void
        """
        if self.init_capacity == 0:
            return
        if key in self.memory_nodes:
            node = self.memory_nodes[key]
            node.value = value

            if node.times + 1 in self.memory_times:
                if self.memory_times[node.times] == node:
                    if node.next.times == node.times:
                        self.memory_times[node.times] = node.next
                    else:
                        del self.memory_times[node.times]
                node.prev.next = node.next
                node.next.prev = node.prev
                node.prev = self.memory_times[node.times + 1].prev
                node.next = self.memory_times[node.times + 1]
                node.next.prev = node
                node.prev.next = node
                self.memory_times[node.times + 1] = node
            else:
                if self.memory_times[node.times] != node:
                    node.prev.next = node.next
                    node.next.prev = node.prev
                    node.prev = self.memory_times[node.times].prev
                    node.next = self.memory_times[node.times]
                    node.next.prev = node
                    node.prev.next = node
                else:
                    if node.next.times == node.times:
                        self.memory_times[node.times] = node.next
                    else:
                        del self.memory_times[node.times]
                self.memory_times[node.times + 1] = node
            node.times += 1
        else:
            node = self.Node(key, value, 1)
            self.memory_nodes[key] = node
            if self.capacity == 0:
                node_to_remove = self.tail.prev
                if self.memory_times[node_to_remove.times] == node_to_remove:
                    del self.memory_times[node_to_remove.times]
                node_to_remove.prev.next = node_to_remove.next
                node_to_remove.next.prev = node_to_remove.prev
                del self.memory_nodes[node_to_remove.key]
                self.capacity += 1
            if 1 in self.memory_times:
                node.prev = self.memory_times[1].prev
                node.next = self.memory_times[1]

            else:
                node.prev = self.tail.prev
                node.next = self.tail
            node.next.prev = node
            node.prev.next = node
            self.memory_times[1] = node
            self.capacity -= 1
```

# 斐波拉契数列

## 31. 自顶向下

```python
def fibonacci(n):
    if n == 1 or n == 2:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)
```

## 32. 自底向上

```python
def fibonacci(n):
    a = 1
    b = 1
    n -= 2
    while n > 0:
        temp = a + b
        a = b
        b = temp
        n -= 1
    return b
```

# 经典题目

## 33. 计算数字二进制表示的1的个数

[Leetcode 461. Hamming Distance][leetcode_461]

```python
def count_1s(num):
    count = 0
    while num:
        num &= (num - 1)
        count += 1
    return count
```

## 34. 数组中除一个数仅出现一次外，其他数均出现两次，找出这个数

[Leetcode 136. Single Number][leetcode_136]

```python
def single_number(nums):
    result = 0
    for num in nums:
        result ^= num
    return result
```

## 35. 长为n的数组中所有元素在[1, n]之间，元素最多出现两次，找出[1, n]中没出现的元素

[Leetcode 448. Find All Numbers Disappeared in an Array][leetcode_448]

```python
def find_disappeared_numbers(nums):
    """
    :type nums: List[int]
    :rtype: List[int]
    """
    for num in nums:
        index = num if num > 0 else -num
        index -= 1
        if nums[index] > 0:
            nums[index] = -nums[index]
    result = []
    for (index, num) in enumerate(nums):
        if num > 0:
            result.append(index + 1)
    return result
```

## 36. 不用`+`和`-`计算两个数的和

[Leetcode 371. Sum of Two Integers][leetcode_371]

```java
public int getSum(int a, int b) {
    int sum = a ^ b;
    int part = a & b;
    while (part != 0) {
        int theA = sum;
        int theB = part << 1;
        sum = theA ^ theB;
        part = theA & theB;
    }
    return sum;
}
```

## 37. 反转二叉树

[Leetcode 226. Invert Binary Tree][leetcode_226]

```python
def invertTree(root):
    """
    :type root: TreeNode
    :rtype: TreeNode
    """
    if root is None:
        return
    self.invertTree(root.left)
    self.invertTree(root.right)
    temp = root.left
    root.left = root.right
    root.right = temp
    return root
```

## 38. 把数组中所有0移动到尾部，数组元素保持相对顺序不变

[Leetcode 283. Move Zeroes][leetcode_283]

```java
public void moveZeroes(int[] nums) {
    int firstZeroIndex = 0;
    while (firstZeroIndex < nums.length && nums[firstZeroIndex] != 0) {
        firstZeroIndex++;
    }
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] != 0 && i > firstZeroIndex) {
            nums[firstZeroIndex] = nums[i];
            nums[i] = 0;
            firstZeroIndex++;
        }
    }
}
```

## 39. 定义一次move是将长为n的数组中n-1个数均加1，最少多少个move可以使得数组中所有元素相等

[Leetcode 453. Minimum Moves to Equal Array Elements][leetcode_453]

```python
def minMoves(nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    return sum(nums) - min(nums) * len(nums)
```

## 40. 找出长为n的数组中出现次数大于⌊ n/2 ⌋的元素

[Leetcode 169. Majority Element][leetcode_169]

```python
def majorityElement(nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    majority = None
    count = 0
    for num in nums:
        if count == 0:
            majority = num
        if majority == num:
            count += 1
        else:
            count -= 1
    return majority
```

## 41. 找出长为n的数组中出现次数大于⌊ n/k ⌋的元素

```python
def majority_element(nums, k):
    counters = {}
    for num in nums:
        if num in counters:
            counters[num] += 1
        elif len(counters.keys()) < k - 1:
            counters[num] = 1
        else:
            for key, count in counters.items():
                if count == 1:
                    del counters[key]
                else:
                    counters[key] -= 1
    for num in counters.keys():
        counters[num] = 0
    for num in nums:
        if num in counters:
            counters[num] += 1
    target = len(nums) // k
    result = []
    for num, count in counters.items():
        if count > target:
            result.append(num)
    return result
```

## 42. 十进制转换为7进制

[Leetcode 504. Base 7][leetcode_504]

```java
public String convertToBase7(int num) {
    if (num == 0) {
        return "0";
    }
    int sign = num >= 0 ? 1 : -1;
    num = Math.abs(num);
    StringBuilder builder = new StringBuilder();
    while (num != 0) {
        builder.append(num % 7);
        num /= 7;
    }
    if (sign < 0) {
        builder.append('-');
    }
    return builder.reverse().toString();
}
```

## 43. 指定长度二进制数，指定1的个数的所有可能情况

[Leetcode 401. Binary Watch][leetcode_401]

```python
def get_combination(length, num_ones):
    def combination(length, num_ones, base, result):
        if num_ones == 0:
            result.append(base)
            return
        if length == 0 or length < num_ones:
            return
        combination(length - 1, num_ones - 1, base + (1 << (length - 1)), result)
        combination(length - 1, num_ones, base, result)

    result = []
    combination(length, num_ones, 0, result)
    return result
```

## 44. 有序数组转二叉搜索树

[Leetcode 108. Convert Sorted Array to Binary Search Tree][leetcode_108]

```java
TreeNode toBST(int[] nums, int start, int end) {
    if (start > end) {
        return null;
    }
    int mid = (start + end) / 2;
    TreeNode node = new TreeNode(nums[mid]);
    node.left = toBST(nums, start, mid - 1);
    node.right = toBST(nums, mid + 1, end);
    return node;
}

public TreeNode sortedArrayToBST(int[] nums) {
    if (nums.length == 0) {
        return null;
    }
    return toBST(nums, 0, nums.length - 1);
}
```

## 45. 最大子数列问题

[Leetcode 121. Best Time to Buy and Sell Stock][leetcode_121]

### 45.1. 最小值为0

```python
def max_subarray(nums):
    max_ending_here = 0
    max_so_far = 0
    for x in nums:
        max_ending_here = max(0, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far
```

### 45.2. 最小值为负数

```python
def max_subarray(nums):
    max_ending_here = nums[0]
    max_so_far = nums[0]
    for x in nums[1:]:
        max_ending_here = max(x, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far
```

## 46. 判断一个数是否为2的幂次

[Leetcode 231. Power of Two][leetcode_231]

```python
def isPowerOfTwo(n):
    """
    :type n: int
    :rtype: bool
    """
    return n > 0 and 0x80000000 % n == 0
```

## 47. 判断一个数是否为4的幂次

[Leetcode 342. Power of Four][leetcode_342]

```python
def isPowerOfFour(num):
    """
    :type num: int
    :rtype: bool
    """
    return num > 0 and num & (num - 1) == 0 and num & 0x55555555 == num
```

## 48. 最近公共祖先问题

### 48.1. 二叉树的最近公共祖先

[Leetcode 236. Lowest Common Ancestor of a Binary Tree][leetcode_236]

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) {
        return root;
    }
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    if (left != null && right != null) {
        return root;
    }
    return left == null ? right : left;
}
```

### 48.2. 二叉搜索树的最近公共祖先

[Leetcode 235. Lowest Common Ancestor of a Binary Search Tree][leetcode_235]

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    while (root != null) {
        if ((p.val < root.val && q.val > root.val)
            || (p.val > root.val && q.val < root.val)
            || p.val == root.val || q.val == root.val) {
            return root;
        }
        if (p.val < root.val && q.val < root.val) {
            root = root.left;
        }
        if (p.val > root.val && q.val > root.val) {
            root = root.right;
        }
    }
    return null;
}
```

## 49. 挑选数组中不连续的元素，使其和最大

[Leetcode 198. House Robber][leetcode_198]

```java
public int rob(int[] nums) {
    if (nums.length == 0) {
        return 0;
    }
    int[] results = new int[nums.length + 1];
    results[0] = 0;
    results[1] = nums[0];
    for (int i = 2; i <= nums.length; i++) {
        results[i] = Math.max(nums[i - 1] + results[i - 2], results[i - 1]);
    }
    return results[nums.length];
}
```

## 50. 镜像二叉树

[Leetcode 101. Symmetric Tree][leetcode_101]

```python
def isSymmetric(root):
    """
    :type root: TreeNode
    :rtype: bool
    """

    def symmetric(left, right):
        if not left and not right:
            return True
        if left and right and left.val == right.val:
            return symmetric(left.left, right.right) and symmetric(left.right, right.left)
        return False

    if not root:
        return True
    return symmetric(root.left, root.right)
```

## 51. 判断二叉树是否平衡

[Leetcode 110. Balanced Binary Tree][leetcode_110]

```python
def isBalanced(root):
    """
    :type root: TreeNode
    :rtype: bool
    """

    def balanced(root):
        if not root:
            return 0
        left = balanced(root.left)
        right = balanced(root.right)
        if left == -1 or right == -1 or abs(left - right) > 1:
            return -1
        return 1 + max(left, right)

    return balanced(root) != -1
```

## 52. 二分法求平方根

[Leetcode 367. Valid Perfect Square][leetcode_367]

```java
public int mySqrt(int x) {
    if (x == 0) {
        return 0;
    }
    int low = 1;
    int high = x;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (mid <= x / mid) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return low - 1;
}
```

## 53. n!求末尾0的个数

[Leetcode 172. Factorial Trailing Zeroes][leetcode_172]

```java
public int trailingZeroes(int n) {
    int result = 0;
    long i = 5;
    while (i <= n) {
        result += n / i;
        i *= 5;
    }
    return result;
}
```

## 54. 有序数组去重

[Leetcode 26. Remove Duplicates from Sorted Array][leetcode_26]

```python
def removeDuplicates(nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    i = 0
    j = 1
    length = len(nums)
    while j < length:
        if nums[i] != nums[j]:
            if (i + 1) == j:
                i += 1
                j += 1
            else:
                nums[i + 1] = nums[j]
                i += 1
                j += 1
        else:
            j += 1
    return i if len(nums) == 0 else i + 1
```

## 55. 链表判断环

[Leetcode 141. Linked List Cycle][leetcode_141]

```python
def hasCycle(head):
    """
    :type head: ListNode
    :rtype: bool
    """
    if not head:
        return False
    walker = head
    runner = head.next
    while walker and runner and runner.next:
        walker = walker.next
        runner = runner.next.next
        if walker == runner:
            return True
    return False
```

## 56. 判断是否为回文数

[Leetcode 9. Palindrome Number][leetcode_9]

```java
public boolean isPalindrome(int x) {
    if (x == 0) {
        return true;
    }
    if (x < 0 || x % 10 == 0) {
        return false;
    }
    int palindrome = 0;
    while (palindrome < x) {
        palindrome = palindrome * 10 + x % 10;
        x /= 10;
    }
    return x == palindrome || x == palindrome / 10;
}
```

## 57. 是否存在二叉树根到叶子节点路径和为指定值

[Leetcode 112. Path Sum][leetcode_112]

```python
def hasPathSum(root, sum):
    """
    :type root: TreeNode
    :type sum: int
    :rtype: bool
    """
    if root is None:
        return False
    if root.val == sum and root.left is None and root.right is None:
        return True

    return hasPathSum(root.left, sum - root.val) or hasPathSum(root.right, sum - root.val)
```

## 58. 找出字符串中所有变位词

[Leetcode 438. Find All Anagrams in a String][leetcode_438]

```java
public List<Integer> findAnagrams(String s, String p) {
    List<Integer> list = new ArrayList<>();
    if (s == null || s.length() == 0 || p == null || p.length() == 0) return list;
    int[] hash = new int[256];
    for (char c : p.toCharArray()) {
        hash[c]++;
    }
    int left = 0, right = 0, count = p.length();
    while (right < s.length()) {
        if (hash[s.charAt(right)] >= 1) {
            count--;
        }
        hash[s.charAt(right)]--;
        right++;
        if (count == 0) {
            list.add(left);
        }
        if (right - left == p.length()) {
            if (hash[s.charAt(left)] >= 0) {
                count++;
            }
            hash[s.charAt(left)]++;
            left++;
        }
    }
    return list;
}
```

## 59. 判断两个字符串是否为同构字符串

[Leetcode 205. Isomorphic Strings][leetcode_205]

```java
public boolean isIsomorphic(String s, String t) {
    if (s.length() != t.length()) {
        return false;
    }
    Map<Character, Integer> pattern = new HashMap<>();
    Set<Character> exist = new HashSet<>();
    for (int i = 0; i < s.length(); i++) {
        boolean sExist = exist.contains(s.charAt(i));
        boolean tExist = pattern.containsKey(t.charAt(i));
        if (sExist && tExist) {
            if (pattern.get(t.charAt(i)) + t.charAt(i) != s.charAt(i)) {
                return false;
            }
        } else if (!sExist && !tExist) {
            exist.add(s.charAt(i));
            pattern.put(t.charAt(i), s.charAt(i) - t.charAt(i));
        } else {
            return false;
        }
    }
    return true;
}
```

## 60. 判断一个数是否为其全部约数的和

[Leetcode 507. Perfect Number][leetcode_507]

```python
def checkPerfectNumber(num):
    """
    :type num: int
    :rtype: bool
    """
    if num == 1:
        return False
    result = 0
    i = 2
    while i * i <= num:
        if num % i == 0:
            result += i
            result += num // i
        i += 1
    result += 1
    return result == num
```

## 61. 打乱数组元素

[Leetcode 384. Shuffle an Array][leetcode_384]

```java
public void shuffle(int[] nums) {
    int length = nums.length;
    Random random = new Random();
    for (int i = 0; i < length; i++) {
        int swapIndex = random.nextInt(length);
        int temp = nums[i];
        nums[i] = nums[swapIndex];
        nums[swapIndex] = temp;
    }
    return nums;
}
```

## 62. 生成不重复随机序列

```java
Random random = new Random();

public int[] randomSequence(int n) {
    int[] sequence = new int[n];
    int[] result = new int[n];
    for (int i = 0; i < n; i++) {
        sequence[i] = i;
    }
    int last = n - 1;
    for (int i = 0; i < n; i++) {
        int index = random.nextInt(last + 1);
        result[i] = sequence[index];
        sequence[index] = sequence[last];
        last--;
    }
    return result;
}
```

## 63. 使用随机生成0到5的函数，实现随机生成0到7的函数

```java
Random random = new Random();

int random5(){
    return random.nextInt(6);
}
int random7(){
    while(true){
        int temp1=random5();
        int temp2=random5();
        int n=temp1*6+temp2;
        if(n<8){
            return n;
        }
    }
}
```

## 64. 计算数组A、B、C、D中有多少种(i, j, k, l)使得A[i] + B[j] + C[k] + D[l] = 0

[Leetcode 454. 4Sum II][leetcode_454]

```python
def fourSumCount(A, B, C, D):
    """
    :type A: List[int]
    :type B: List[int]
    :type C: List[int]
    :type D: List[int]
    :rtype: int
    """
    sumABDict = {}
    for a in A:
        for b in B:
            sumAB = a + b
            if sumAB not in sumABDict:
                sumABDict[sumAB] = 0
            sumABDict[sumAB] += 1
    result = 0
    for c in C:
        for d in D:
            sumCD = -c - d
            if sumCD in sumABDict:
                result += sumABDict[sumCD]
    return result
```

## 65. 计算给出的多个时间中，最小的时间差

[Leetcode 539. Minimum Time Difference][leetcode_539]

```java
public int findMinDifference(List<String> timePoints) {
    boolean[] mark = new boolean[24 * 60];
    for (String time : timePoints) {
        String[] t = time.split(":");
        int h = Integer.parseInt(t[0]);
        int m = Integer.parseInt(t[1]);
        if (mark[h * 60 + m]) return 0;
        mark[h * 60 + m] = true;
    }
    int prev = 0, min = Integer.MAX_VALUE;
    int first = Integer.MAX_VALUE, last = Integer.MIN_VALUE;
    for (int i = 0; i < 24 * 60; i++) {
        if (mark[i]) {
            if (first != Integer.MAX_VALUE) {
                min = Math.min(min, i - prev);
            }
            first = Math.min(first, i);
            last = Math.max(last, i);
            prev = i;
        }
    }
    min = Math.min(min, (24 * 60 - last + first));
    return min;
}
```

## 66. 计算\[0, 10^n)中各位数字不同的数的个数

[Leetcode 357. Count Numbers with Unique Digits][leetcode_357]

```python
def countNumbersWithUniqueDigits(n):
    """
    :type n: int
    :rtype: int
    """
    if n == 0:
        return 1
    map = [None] * (n + 1)
    map[1] = 10
    for i in range(2, n + 1):
        count = 9
        for j in range(9 - i + 2, 10):
            count *= j
        map[i] = map[i - 1] + count
    return map[n]
```

## 67. 数组中仅有两个数仅出现一次，其余的数均出现两次，找出这两个数

[Leetcode 260. Single Number III][leetcode_260]

```python
def singleNumber(nums):
    """
    :type nums: List[int]
    :rtype: List[int]
    """
    mixed_xor = 0
    for num in nums:
        mixed_xor ^= num
    diff = mixed_xor & (mixed_xor - 1) ^ mixed_xor
    first = 0
    second = 0
    for num in nums:
        if diff & num:
            first ^= num
        else:
            second ^= num
    return [first, second]
```

## 68. 找出递增数列中第n位的数字

[Leetcode 400. Nth Digit][leetcode_400]

```python
def findNthDigit(n):
    """
    :type n: int
    :rtype: int
    """
    digits = 1
    start = 1
    length = 9
    while (n > digits * length):
        n -= digits * length
        digits += 1
        start *= 10
        length *= 10
    n -= 1
    number = start + n // digits
    return int(str(number)[n % digits])
```

## 69. 计算小于n的质数的个数

[Leetcode 204. Count Primes][leetcode_204]

```python
def countPrimes(n):
    """
    :type n: int
    :rtype: int
    """
    if n < 2:
        return 0
    primes = [True] * n
    primes[0] = False
    primes[1] = False
    for i in range(2, int(n ** 0.5) + 1):
        if primes[i]:
            for j in range(i * i, n, i):
                primes[j] = False
    return sum(primes)
```

## 70. 由部分（可重复）给定数组元素相加得到指定值的情况数

[Leetcode 377. Combination Sum IV][leetcode_377]

```java
public int combinationSum4(int[] nums, int target) {
    int[] results = new int[target + 1];
    results[0] = 1;
    for (int i = 1; i <= target; i++) {
        for (int num : nums) {
            if (i - num >= 0) {
                results[i] += results[i - num];
            }
        }
    }
    return results[target];
}
```

## 71. 在有序矩阵中寻找第k大的数

[Leetcode 378. Kth Smallest Element in a Sorted Matrix][leetcode_378]

```java
public int kthSmallest(int[][] matrix, int k) {
    class Item {
        int value;
        int i;
        int j;

        public Item(int value, int i, int j) {
            this.value = value;
            this.i = i;
            this.j = j;
        }
    }
    int m = matrix.length;
    int n = matrix[0].length;
    PriorityQueue<Item> minHeap = new PriorityQueue<>(new Comparator<Item>() {
        @Override
        public int compare(Item o1, Item o2) {
            return o1.value - o2.value;
        }
    });
    for (int j = 0; j < n; j++) {
        minHeap.add(new Item(matrix[0][j], 0, j));
    }
    while (!minHeap.isEmpty()) {
        Item item = minHeap.poll();
        if (item.i < m - 1) {
            minHeap.add(new Item(matrix[item.i + 1][item.j], item.i + 1, item.j));
        }
        k--;
        if (k == 0) {
            return item.value;
        }
    }
    return 0;
}
```

## 72. 求n对括号的所有排列情况

[Leetcode 22. Generate Parentheses][leetcode_22]

```python
def generateParenthesis(n):
    """
    :type n: int
    :rtype: List[str]
    """

    def parenthesis(result, current, left, right):
        if left == 0 and right == 0:
            result.append(current)
        elif left >= 0 and right >= left:
            parenthesis(result, current + '(', left - 1, right)
            parenthesis(result, current + ')', left, right - 1)

    result = []
    parenthesis(result, '', n, n)
    return result
```

## 73. 给定字符串数组，求最大不相交的两个字符串的长度积

[Leetcode 318. Maximum Product of Word Lengths][leetcode_318]

```java
public int maxProduct(String[] words) {
    int[] bits = new int[words.length];
    int result = 0;
    for (int i = 0; i < words.length; i++) {
        int bit = 0;
        for (char letter : words[i].toCharArray()) {
            bit |= 1 << (letter - 'a');
        }
        bits[i] = bit;
    }
    for (int i = 0; i < bits.length; i++) {
        for (int j = i + 1; j < bits.length; j++) {
            if ((bits[i] & bits[j]) == 0 && words[i].length() * words[j].length() > result) {
                result = words[i].length() * words[j].length();
            }
        }
    }
    return result;
}
```

## 74. 在由[1, n]组成的长为n + 1的数组中，寻找重复的那个数

[Leetcode 287. Find the Duplicate Number][leetcode_287]

```java
public int findDuplicate(int[] nums) {
    int low = 1;
    int high = nums.length - 1;
    while (low < high) {
        int mid = (low + high) / 2;
        int count = 0;
        for (int num : nums) {
            if (num <= mid) {
                count++;
            }
        }
        if (count <= mid) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    return low;
}
```

## 75. 求给定数组的所有排列情况

[Leetcode 46. Permutations][leetcode_46]

```java
public List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    result.add(new ArrayList<>());
    for (int i = 0; i < nums.length; i++) {
        List<List<Integer>> newResult = new ArrayList<>();
        for (int j = 0; j <= i; j++) {
            for (List<Integer> item : result) {
                List<Integer> newItem = new ArrayList<>(item);
                newItem.add(j, nums[i]);
                newResult.add(newItem);
            }
        }
        result = newResult;
    }
    return result;
}
```

## 76. 最长回文子序列

[Leetcode 516. Longest Palindromic Subsequence][leetcode_516]

```java
public int longestPalindromeSubseq(String s) {
    int[][] dp = new int[s.length()][s.length()];
    for (int i = s.length() - 1; i >= 0; i--) {
        dp[i][i] = 1;
        for (int j = i + 1; j < s.length(); j++) {
            if (s.charAt(i) == s.charAt(j)) {
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[0][s.length() - 1];
}
```

## 77. 将[1, n]的数按字典排序

[Leetcode 386. Lexicographical Numbers][leetcode_386]

```python
def lexicalOrder(n):
    """
    :type n: int
    :rtype: List[int]
    """

    def dfs(result, current, n):
        if current > n:
            return
        result.append(current)
        current *= 10
        if current <= n:
            for i in range(10):
                if current + i <= n:
                    dfs(result, current + i, n)

    result = []
    for i in range(1, 10):
        dfs(result, i, n)
    return result
```

## 78. 二叉搜索树迭代器

[Leetcode 173. Binary Search Tree Iterator][leetcode_173]

```python
class BSTIterator(object):
    def __init__(self, root):
        """
        :type root: TreeNode
        """
        self.stack = []
        while root:
            self.stack.append(root)
            root = root.left

    def hasNext(self):
        """
        :rtype: bool
        """
        return self.stack

    def next(self):
        """
        :rtype: int
        """
        node = self.stack.pop()
        result = node.val
        node = node.right
        while node:
            self.stack.append(node)
            node = node.left
        return result
```

## 79. 由[1, n]组成的二叉搜索树的个数

[Leetcode 96. Unique Binary Search Trees][leetcode_96]

```java
public int numTrees(int n) {
    int[] results = new int[n + 1];
    results[0] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < i; j++) {
            results[i] += results[j] * results[i - j - 1];
        }
    }
    return results[n];
}
```

## 80. 格雷码

[Leetcode 89. Gray Code][leetcode_89]

```python
def grayCode(n):
    """
    :type n: int
    :rtype: List[int]
    """
    return [i ^ (i >> 1) for i in range(1 << n)]
```

## 81. 从m x n棋盘左上角走到右下角的路径总数

[Leetcode 62. Unique Paths][leetcode_62]

```java
public int uniquePaths(int m, int n) {
    int[][] dp = new int[m][n];
    for (int i = 0; i < m; i++) {
        dp[i][0] = 1;
    }
    for (int j = 0; j < n; j++) {
        dp[0][j] = 1;
    }
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}
```

## 82. 求循环移位的有序数组中的到最小值

[Leetcode 153. Find Minimum in Rotated Sorted Array][leetcode_153]

```java
public int findMin(int[] nums) {
    int low = 0;
    int high = nums.length - 1;
    while (low < high) {
        if (nums[low] < nums[high]) {
            return nums[low];
        }
        int mid = (low + high) / 2;
        if (nums[mid] >= nums[low]) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    return nums[low];
}
```

## 83. 求集合的所有子集

[Leetcode 78. Subsets][leetcode_78]

```python
def subsets(nums):
    """
    :type nums: List[int]
    :rtype: List[List[int]]
    """
    result = []
    for i in range(1 << len(nums)):
        current = []
        for j in range(len(nums)):
            if i & 1 << j:
                current.append(nums[j])
        result.append(current)
    return result
```

## 84. 判断数组arr中是否存在arr[i] &lt; arr[j] &lt; arr[k]

[Leetcode 334. Increasing Triplet Subsequence][leetcode_334]

```java
public boolean increasingTriplet(int[] nums) {
    int first = Integer.MAX_VALUE;
    int second = Integer.MAX_VALUE;
    for (int num : nums) {
        if (num < first) {
            first = num;
        } else if (num < second && num > first) {
            second = num;
        } else if (num > second) {
            return true;
        }
    }
    return false;
}
```

## 85. 查找数组中第k大的数

[Leetcode 215. Kth Largest Element in an Array][leetcode_215]

```python
def find_kth_largest(nums, k):
    def partition(array, low, high):
        pivot = array[low]
        while low < high:
            while low < high and array[high] >= pivot:
                high -= 1
            array[low] = array[high]
            while low < high and array[low] <= pivot:
                low += 1
            array[high] = array[low]
        array[low] = pivot
        return low

    random.shuffle(nums)
    k = len(nums) - k
    low = 0
    high = len(nums) - 1
    while low < high:
        index = partition(nums, low, high)
        if index < k:
            low = index + 1
        elif index > k:
            high = index - 1
        else:
            break
    return nums[k]
```

## 86. 链表删除倒数第n个结点

[Leetcode 19. Remove Nth Node From End of List][leetcode_19]

```python
def removeNthFromEnd(head, n):
    """
    :type head: ListNode
    :type n: int
    :rtype: ListNode
    """
    first = head
    second = head
    prev = head
    while n:
        first = first.next
        n -= 1
    while first:
        first = first.next
        prev = second
        second = second.next
    if second == head:
        return head.next
    prev.next = prev.next.next
    return head
```

## 87. 判断数组是否可以拼接为正方形

[Leetcode 473. Matchsticks to Square][leetcode_473]

```java
public boolean makesquare(int[] nums) {
    class Utils {
        boolean square(int[] nums, int[] edges, int start) {
            if (start == nums.length) {
                return edges[0] == 0 && edges[1] == 0 && edges[2] == 0 && edges[3] == 0;
            }
            int current = nums[start];
            for (int i = 0; i < edges.length; i++) {
                if (edges[i] >= current) {
                    edges[i] -= current;
                    if (square(nums, edges, start + 1)) {
                        return true;
                    }
                    edges[i] += current;
                }
            }
            return false;
        }
    }
    if (nums.length < 4) {
        return false;
    }
    int sumNums = 0;
    for (int num : nums) {
        sumNums += num;
    }
    if (sumNums % 4 != 0) {
        return false;
    }
    int[] edges = new int[4];
    Arrays.fill(edges, sumNums / 4);
    Arrays.sort(nums);
    for (int left = 0, right = nums.length - 1; left < right; left++, right--) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
    Utils utils = new Utils();
    return utils.square(nums, edges, 0);
}
```

## 88. 快速`pow()`

[Leetcode 372. Super Pow][leetcode_372]

```java
public int normalPow(int a, int b) {
    int result = 1;
    while (b != 0) {
        if (b % 2 != 0)
            result = result * a % M;
        a = a * a % M;
        b /= 2;
    }
    return result;
}

public int superPow(int a, int[] b) {
    a %= M;
    int result = 1;
    for (int i = b.length - 1; i >= 0; i--) {
        result = result * normalPow(a, b[i]) % M;
        a = normalPow(a, 10);
    }
    return result;
```

## 89. 判断数组是否可以分为相等的两部分

[Leetcode 416. Partition Equal Subset Sum][leetcode_416]

```java
public boolean canPartition(int[] nums) {
    int target = 0;
    for (int num : nums) {
        target += num;
    }
    if (target % 2 == 1) {
        return false;
    }
    target /= 2;
    boolean[][] dp = new boolean[nums.length + 1][target + 1];
    dp[0][0] = true;
    for (int i = 1; i <= nums.length; i++) {
        for (int j = 0; j <= target; j++) {
            dp[i][j] = dp[i - 1][j];
            if (j >= nums[i - 1]) {
                dp[i][j] = dp[i][j] || dp[i - 1][j - nums[i - 1]];
            }
        }
    }
    return dp[nums.length][target];
}
```

## 90. 在矩阵中查找指定值

[Leetcode 240. Search a 2D Matrix II][leetcode_240]

```python
def searchMatrix(matrix, target):
    """
    :type matrix: List[List[int]]
    :type target: int
    :rtype: bool
    """
    if not matrix:
        return False
    i = 0
    j = len(matrix[0]) - 1
    while i < len(matrix) and j >= 0:
        current = matrix[i][j]
        if current == target:
            return True
        elif current > target:
            j -= 1
        else:
            i += 1
    return False
```

## 91. 将矩阵顺时针旋转90度

[Leetcode 48. Rotate Image][leetcode_48]

```python
def rotate(matrix):
    """
    :type matrix: List[List[int]]
    :rtype: void Do not return anything, modify matrix in-place instead.
    """
    m = len(matrix)
    n = len(matrix[0])
    for i in range(m // 2):
        matrix[i], matrix[m - i - 1] = matrix[m - i - 1], matrix[i]
    for i in range(m):
        for j in range(i + 1, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
```

## 92. 最长递增子序列

[Leetcode 300. Longest Increasing Subsequence][leetcode_300]

```python
def lengthOfLIS(nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)
```

## 93. 求二维矩阵由左上角到右下角的最小和

[Leetcode 64. Minimum Path Sum][leetcode_64]

```java
public int minPathSum(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    int[][] dp = new int[m][n];
    dp[0][0] = grid[0][0];
    for (int i = 1; i < m; i++) {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
    }
    for (int j = 1; j < n; j++) {
        dp[0][j] = dp[0][j - 1] + grid[0][j];
    }
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
        }
    }
    return dp[m - 1][n - 1];
}
```

## 94. 将由0、1、2组成的数组排序

[Leetcode 75. Sort Colors][leetcode_75]

```python
def sortColors(nums):
    """
    :type nums: List[int]
    :rtype: void Do not return anything, modify nums in-place instead.
    """
    left = 0
    while left < len(nums) and nums[left] == 0:
        left += 1
    right = len(nums) - 1
    while right >= 0 and nums[right] == 2:
        right -= 1
    current = left
    while current <= right and left <= right:
        if nums[current] == 0:
            if current == left:
                current += 1
            else:
                nums[left], nums[current] = nums[current], nums[left]
            left += 1
        elif nums[current] == 2:
            if current == right:
                current += 1
            else:
                nums[right], nums[current] = nums[current], nums[right]
            right -= 1
        else:
            current += 1
```

## 95. 求第n位仅由指定因数组成的数字

[Leetcode 313. Super Ugly Number][leetcode_313]

```java
public int nthSuperUglyNumber(int n, int[] primes) {
    int[] factors = new int[primes.length];
    Arrays.fill(factors, 1);
    int[] indexes = new int[primes.length];
    Arrays.fill(indexes, -1);
    int[] ugly = new int[n];
    for (int i = 0; i < n; i++) {
        int theMin = Integer.MAX_VALUE;
        for (int factor : factors) {
            theMin = Math.min(theMin, factor);
        }
        ugly[i] = theMin;
        for (int j = 0; j < factors.length; j++) {
            if (ugly[i] == factors[j]) {
                indexes[j]++;
                factors[j] = ugly[indexes[j]] * primes[j];
            }
        }
    }
    return ugly[ugly.length - 1];
}
```

## 96. 数组中查找极大值

[Leetcode 162. Find Peak Elementr][leetcode_162]

```java
public int findPeakElement(int[] nums) {
    if (nums.length == 1 || nums[0] > nums[1]) {
        return 0;
    }
    if (nums[nums.length - 2] < nums[nums.length - 1]) {
        return nums.length - 1;
    }
    int low = 0;
    int high = nums.length - 1;
    while (low < high) {
        int mid = (low + high) / 2;
        if (nums[mid] < nums[mid + 1]) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    return low;
}
```

## 97. 判断n能否由平方数的和组成

[Leetcode 279. Perfect Squares][leetcode_279]

```python
def numSquares(self, n):
    """
    :type n: int
    :rtype: int
    """
    dp = [n] * (n + 1)
    dp[0] = 0
    for i in range(1, n + 1):
        j = 1
        while j * j <= i:
            dp[i] = min(dp[i], dp[i - j * j] + 1)
            j += 1
    return dp[n]
```

## 98. 删除二叉搜索树中的结点

[Leetcode 450. Delete Node in a BST][leetcode_450]

```python
def deleteNode(root, key):
    """
    :type root: TreeNode
    :type key: int
    :rtype: TreeNode
    """
    if not root:
        return None
    if root.val > key:
        root.left = deleteNode(root.left, key)
    elif root.val < key:
        root.right = deleteNode(root.right, key)
    else:
        if not root.left:
            return root.right
        elif not root.right:
            return root.left
        else:
            replace = root.right
            while replace.left:
                replace = replace.left
            root.val = replace.val
            root.right = deleteNode(root.right, root.val)
    return root
```

## 99. 检查字符串是否是合法的二叉树前序遍历结果

[Leetcode 331. Verify Preorder Serialization of a Binary Tree][leetcode_331]

```python
def isValidSerialization(self, preorder):
    """
    :type preorder: str
    :rtype: bool
    """
    degree = -1
    for node in preorder.split(','):
        degree += 1
        if degree > 0:
            return False
        if node != '#':
            degree -= 2
    return degree == 0
```

## 100. 中缀表达式转后缀表达式

```java
String infixToPostfix(String infix) {
    Map<Character, Integer> priority = new HashMap<>();
    priority.put('(', 1);
    priority.put(')', -1);
    priority.put('+', 2);
    priority.put('-', 2);
    priority.put('*', 3);
    priority.put('/', 3);
    priority.put('^', 3);
    StringBuilder builder = new StringBuilder();
    Stack<Character> stack = new Stack<>();
    for (char c : infix.toCharArray()) {
        if (priority.containsKey(c)) {
            if (c == '(') {
                stack.push(c);
            } else if (c == ')') {
                while (!stack.empty() && stack.peek() != '(') {
                    builder.append(stack.pop());
                }
                if (!stack.empty()) {
                    stack.pop();
                }
            } else {
                while (!stack.empty() && priority.get(stack.peek()) >= priority.get(c)) {
                    builder.append(stack.pop());
                }
                stack.push(c);
            }
        } else {
            builder.append(c);
        }
    }
    while (!stack.empty()) {
        builder.append(stack.pop());
    }
    return builder.toString();
}
```

## 101. 快速替换10亿条标题中的5万个敏感词

Aho-Corasick算法（AC自动机）：

- 构造一棵Trie树；
- 构造失败指针；
- 模式匹配。

参考：[AC自动机算法详解 - 极限定律 - C++博客][aho_corasick_algorithm]

## 102. 轮流取数的必胜策略

问题描述：有2N个自然数，甲乙两人轮流取。一人一次取一个，而且只能取头尾两个数中的一个，取过的数划去，直到2N个数取完，取得的数的总和大的人获胜。那么，先取的人是否有必胜策略？

解决方法：先取的人只要取了奇数位上的数，就把偶数位的数留给后取的人，而且只要坚持取奇数位上的数，就一直会把偶数位上的数留给后取的人。这样就会取走所有奇数位上的数。（这种方法同样可使先取的人把所有偶数位上的数取走）所以，先取的人只要一开始算出是所有偶数位上的数总和大，还是所有奇数位上的数总和大，就一定会胜。

## 103. 最大公约数（辗转相除法）

```python
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a
```

## 104. 最小公倍数

`(a * b)/gcd(a, b)`

[leetcode_461]: https://leetcode.com/problems/hamming-distance/#/description

[leetcode_136]: https://leetcode.com/problems/single-number/#/description

[leetcode_448]: https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/#/description

[leetcode_371]: https://leetcode.com/problems/sum-of-two-integers/#/description

[leetcode_226]: https://leetcode.com/problems/invert-binary-tree/#/description

[leetcode_283]: https://leetcode.com/problems/move-zeroes/#/description

[leetcode_453]: https://leetcode.com/problems/minimum-moves-to-equal-array-elements/#/description

[leetcode_169]: https://leetcode.com/problems/majority-element/#/description

[leetcode_504]: https://leetcode.com/problems/base-7/#/description

[leetcode_401]: https://leetcode.com/problems/binary-watch/#/description

[leetcode_108]: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/#/description

[leetcode_121]: https://leetcode.com/problems/best-time-to-buy-and-sell-stock/#/description

[leetcode_231]: https://leetcode.com/problems/power-of-two/#/description

[leetcode_342]: https://leetcode.com/problems/power-of-four/#/description

[leetcode_198]: https://leetcode.com/problems/house-robber/#/description

[leetcode_101]: https://leetcode.com/problems/symmetric-tree/#/description

[leetcode_110]: https://leetcode.com/problems/balanced-binary-tree/#/description

[leetcode_367]: https://leetcode.com/problems/valid-perfect-square/#/description

[leetcode_172]: https://leetcode.com/problems/factorial-trailing-zeroes/#/description

[leetcode_26]: https://leetcode.com/problems/remove-duplicates-from-sorted-array/#/description

[leetcode_141]: https://leetcode.com/problems/linked-list-cycle/#/description

[leetcode_9]: https://leetcode.com/problems/palindrome-number/#/description

[leetcode_112]: https://leetcode.com/problems/path-sum/#/description

[leetcode_438]: https://leetcode.com/problems/find-all-anagrams-in-a-string/#/description

[leetcode_205]: https://leetcode.com/problems/isomorphic-strings/#/description

[leetcode_507]: https://leetcode.com/problems/perfect-number/#/description

[leetcode_384]: https://leetcode.com/problems/shuffle-an-array/#/description

[leetcode_454]: https://leetcode.com/problems/4sum-ii/#/description

[leetcode_539]: https://leetcode.com/problems/minimum-time-difference/#/description

[leetcode_357]: https://leetcode.com/problems/count-numbers-with-unique-digits/#/description

[leetcode_260]: https://leetcode.com/problems/single-number-iii/#/description

[leetcode_400]: https://leetcode.com/problems/nth-digit/#/description

[leetcode_204]: https://leetcode.com/problems/count-primes/#/description

[leetcode_377]: https://leetcode.com/problems/combination-sum-iv/#/description

[leetcode_378]: https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/#/description

[leetcode_22]: https://leetcode.com/problems/generate-parentheses/#/description

[leetcode_318]: https://leetcode.com/problems/maximum-product-of-word-lengths/#/description

[leetcode_287]: https://leetcode.com/problems/find-the-duplicate-number/#/description

[leetcode_46]: https://leetcode.com/problems/permutations/#/description

[leetcode_516]: https://leetcode.com/problems/longest-palindromic-subsequence/#/description

[leetcode_386]: https://leetcode.com/problems/lexicographical-numbers/#/description

[leetcode_173]: https://leetcode.com/problems/binary-search-tree-iterator/#/description

[leetcode_96]: https://leetcode.com/problems/unique-binary-search-trees/#/description

[leetcode_89]: https://leetcode.com/problems/gray-code/#/description

[leetcode_62]: https://leetcode.com/problems/unique-paths/#/description

[leetcode_153]: https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/#/description

[leetcode_78]: https://leetcode.com/problems/subsets/#/description

[leetcode_334]: https://leetcode.com/problems/increasing-triplet-subsequence/#/description

[leetcode_215]: https://leetcode.com/problems/kth-largest-element-in-an-array/#/description

[leetcode_19]: https://leetcode.com/problems/remove-nth-node-from-end-of-list/#/description

[leetcode_473]: https://leetcode.com/problems/matchsticks-to-square/#/description

[leetcode_372]: https://leetcode.com/problems/super-pow/#/description

[leetcode_416]: https://leetcode.com/problems/partition-equal-subset-sum/#/description

[leetcode_240]: https://leetcode.com/problems/search-a-2d-matrix-ii/#/description

[leetcode_48]: https://leetcode.com/problems/rotate-image/#/description

[leetcode_300]: https://leetcode.com/problems/longest-increasing-subsequence/#/description

[leetcode_64]: https://leetcode.com/problems/minimum-path-sum/#/description

[leetcode_75]: https://leetcode.com/problems/sort-colors/#/description

[leetcode_313]: https://leetcode.com/problems/super-ugly-number/#/description

[leetcode_162]: https://leetcode.com/problems/find-peak-element/#/description

[leetcode_279]: https://leetcode.com/problems/perfect-squares/#/description

[leetcode_450]: https://leetcode.com/problems/delete-node-in-a-bst/#/description

[leetcode_331]: https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/#/description

[aho_corasick_algorithm]: http://www.cppblog.com/mythit/archive/2009/04/21/80633.html

[leetcode_235]: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/

[leetcode_236]: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/
